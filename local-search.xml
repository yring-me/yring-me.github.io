<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Loading a Binary</title>
    <link href="/2023/05/26/Loading%20a%20Binary/"/>
    <url>/2023/05/26/Loading%20a%20Binary/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.angr.io/en/latest/core-concepts/loading.html">Loading a Binary</a></p><span id="more"></span><p>angr是通过CLE模块来装载一个二进制文件，也就是说CLE的接口也可以用于angr。</p><h2 id="The-Loader"><a href="#The-Loader" class="headerlink" title="The Loader"></a>The Loader</h2><p>目前我们可以用以下几行代码装载一个二进制文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr, monkeyhex<br>proj = angr.Project(<span class="hljs-string">&#x27;examples/fauxware/fauxware&#x27;</span>)<br>proj.loader<br>&lt;Loaded fauxware, maps [<span class="hljs-number">0x400000</span>:<span class="hljs-number">0x5008000</span>]&gt;<br></code></pre></td></tr></table></figure><h3 id="Loaded-Objects"><a href="#Loaded-Objects" class="headerlink" title="Loaded Objects"></a>Loaded Objects</h3><p>前面提到Angr使用CLE来装载二进制文件，而CLE装载器即<code>cle.Loader</code>装载了这个二进制文件的所有objects，并且把他们映射到一个内存地址。每一个不同类型的binary objec都可以由<code>cle.Backend</code>处理，比如<code>cle.ELF</code>就是用来装载ELF文件。</p><h4 id="loader-all-objects"><a href="#loader-all-objects" class="headerlink" title="loader.all_objects"></a>loader.all_objects</h4><p>可以通过<code>loader.all_objects</code>来获得CLE装载所有objects的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># All loaded objects</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.all_objects<br>[&lt;ELF Object fauxware, maps [<span class="hljs-number">0x400000</span>:<span class="hljs-number">0x60105f</span>]&gt;,<br> &lt;ELF Object libc-<span class="hljs-number">2.23</span>.so, maps [<span class="hljs-number">0x1000000</span>:<span class="hljs-number">0x13c999f</span>]&gt;,<br> &lt;ELF Object ld-<span class="hljs-number">2.23</span>.so, maps [<span class="hljs-number">0x2000000</span>:<span class="hljs-number">0x2227167</span>]&gt;,<br> &lt;ELFTLSObject Object cle<span class="hljs-comment">##tls, maps [0x3000000:0x3015010]&gt;,</span><br> &lt;ExternObject Object cle<span class="hljs-comment">##externs, maps [0x4000000:0x4008000]&gt;,</span><br> &lt;KernelObject Object cle<span class="hljs-comment">##kernel, maps [0x5000000:0x5008000]&gt;]</span><br><br><span class="hljs-comment"># main object 也就是需要我们关注的那个object</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.main_object<br>&lt;ELF Object fauxware, maps [<span class="hljs-number">0x400000</span>:<span class="hljs-number">0x60105f</span>]&gt;<br><br><span class="hljs-comment"># 从名字到地址的映射</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.shared_objects<br>&#123; <span class="hljs-string">&#x27;fauxware&#x27;</span>: &lt;ELF Object fauxware, maps [<span class="hljs-number">0x400000</span>:<span class="hljs-number">0x60105f</span>]&gt;,<br>  <span class="hljs-string">&#x27;libc.so.6&#x27;</span>: &lt;ELF Object libc-<span class="hljs-number">2.23</span>.so, maps [<span class="hljs-number">0x1000000</span>:<span class="hljs-number">0x13c999f</span>]&gt;,<br>  <span class="hljs-string">&#x27;ld-linux-x86-64.so.2&#x27;</span>: &lt;ELF Object ld-<span class="hljs-number">2.23</span>.so, maps [<span class="hljs-number">0x2000000</span>:<span class="hljs-number">0x2227167</span>]&gt; &#125;<br><br><span class="hljs-comment"># 从ELF装载的所有文件</span><br><span class="hljs-comment"># 如果是PE程序 使用all_pe_objects</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.all_elf_objects<br>[&lt;ELF Object fauxware, maps [<span class="hljs-number">0x400000</span>:<span class="hljs-number">0x60105f</span>]&gt;,<br> &lt;ELF Object libc-<span class="hljs-number">2.23</span>.so, maps [<span class="hljs-number">0x1000000</span>:<span class="hljs-number">0x13c999f</span>]&gt;,<br> &lt;ELF Object ld-<span class="hljs-number">2.23</span>.so, maps [<span class="hljs-number">0x2000000</span>:<span class="hljs-number">0x2227167</span>]&gt;]<br><br><span class="hljs-comment"># 处理外部导入</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.extern_object<br>&lt;ExternObject Object cle<span class="hljs-comment">##externs, maps [0x4000000:0x4008000]&gt;</span><br><br><span class="hljs-comment"># 此object提供系统调用地址</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.kernel_object<br>&lt;KernelObject Object cle<span class="hljs-comment">##kernel, maps [0x5000000:0x5008000]&gt;</span><br><br><span class="hljs-comment"># 通过地址找object</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>proj.loader.find_object_containing(<span class="hljs-number">0x400000</span>)<br>&lt;ELF Object fauxware, maps [<span class="hljs-number">0x400000</span>:<span class="hljs-number">0x60105f</span>]&gt;<br></code></pre></td></tr></table></figure><h4 id="与object交互"><a href="#与object交互" class="headerlink" title="与object交互"></a>与object交互</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = proj.loader.main_object<br><br><span class="hljs-comment"># 入口点</span><br>obj.entry<br><span class="hljs-number">0x400580</span><br><br><span class="hljs-comment"># 起始 终止</span><br>obj.min_addr, obj.max_addr<br>(<span class="hljs-number">0x400000</span>, <span class="hljs-number">0x60105f</span>)<br><br><span class="hljs-comment"># segments</span><br>obj.segments<br>&lt;Regions: [&lt;ELFSegment memsize=<span class="hljs-number">0xa74</span>, filesize=<span class="hljs-number">0xa74</span>, vaddr=<span class="hljs-number">0x400000</span>, flags=<span class="hljs-number">0x5</span>, offset=<span class="hljs-number">0x0</span>&gt;,<br>           &lt;ELFSegment memsize=<span class="hljs-number">0x238</span>, filesize=<span class="hljs-number">0x228</span>, vaddr=<span class="hljs-number">0x600e28</span>, flags=<span class="hljs-number">0x6</span>, offset=<span class="hljs-number">0xe28</span>&gt;]&gt;<br><span class="hljs-comment"># sections</span><br>obj.sections<br>&lt;Regions: [&lt;Unnamed | offset <span class="hljs-number">0x0</span>, vaddr <span class="hljs-number">0x0</span>, size <span class="hljs-number">0x0</span>&gt;,<br>           &lt;.interp | offset <span class="hljs-number">0x238</span>, vaddr <span class="hljs-number">0x400238</span>, size <span class="hljs-number">0x1c</span>&gt;,<br>           &lt;.note.ABI-tag | offset <span class="hljs-number">0x254</span>, vaddr <span class="hljs-number">0x400254</span>, size <span class="hljs-number">0x20</span>&gt;,<br>            ...etc<br><br><span class="hljs-comment"># 利用地址去找segment 或者 section</span><br>obj.find_segment_containing(obj.entry)<br>&lt;ELFSegment memsize=<span class="hljs-number">0xa74</span>, filesize=<span class="hljs-number">0xa74</span>, vaddr=<span class="hljs-number">0x400000</span>, flags=<span class="hljs-number">0x5</span>, offset=<span class="hljs-number">0x0</span>&gt;<br>obj.find_section_containing(obj.entry)<br>&lt;.text | offset <span class="hljs-number">0x580</span>, vaddr <span class="hljs-number">0x400580</span>, size <span class="hljs-number">0x338</span>&gt;<br><br><span class="hljs-comment"># plt表找符号</span><br>addr = obj.plt[<span class="hljs-string">&#x27;strcmp&#x27;</span>]<br>addr<br><span class="hljs-number">0x400550</span><br>obj.reverse_plt[addr]<br><span class="hljs-string">&#x27;strcmp&#x27;</span><br><br><span class="hljs-comment"># Show the prelinked base of the object and the location it was actually mapped into memory by CLE</span><br>obj.linked_base<br><span class="hljs-number">0x400000</span><br>obj.mapped_base<br><span class="hljs-number">0x400000</span><br></code></pre></td></tr></table></figure><h3 id="Symbols-and-Relocations"><a href="#Symbols-and-Relocations" class="headerlink" title="Symbols and Relocations"></a>Symbols and Relocations</h3><p>symbol是可执行文件的重要概念，完成从名字到地址的映射</p><p>可以利用<code>loader.find_symbol</code>寻找特定symbol,它的参数可以是名字，也可以是地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">strcmp = proj.loader.find_symbol(<span class="hljs-string">&#x27;strcmp&#x27;</span>)<br>strcmp<br>&lt;Symbol <span class="hljs-string">&quot;strcmp&quot;</span> <span class="hljs-keyword">in</span> libc.so<span class="hljs-number">.6</span> at <span class="hljs-number">0x1089cd0</span>&gt;<br></code></pre></td></tr></table></figure><p>symbol有三种形式地址</p><p><code>.rebased_addr</code> 是全局地址空间的地址</p><p><code>.linked_addr</code> 预链接地址</p><p><code>.relative_addr</code> 即RVA</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">strcmp.name<br><span class="hljs-string">&#x27;strcmp&#x27;</span><br><br>strcmp.owner<br>&lt;ELF Object libc-<span class="hljs-number">2.23</span>.so, maps [<span class="hljs-number">0x1000000</span>:<span class="hljs-number">0x13c999f</span>]&gt;<br><br>strcmp.rebased_addr<br><span class="hljs-number">0x1089cd0</span><br>strcmp.linked_addr<br><span class="hljs-number">0x89cd0</span><br>strcmp.relative_addr<br><span class="hljs-number">0x89cd0</span><br></code></pre></td></tr></table></figure><h2 id="Loading-Options"><a href="#Loading-Options" class="headerlink" title="Loading Options"></a>Loading Options</h2><p>可以给angr.Project传一些参数，以此来约束加载二进制文件的行为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>auto_load_libs  决定是否加载动态链接库，默认开启<br><span class="hljs-number">2.</span>skip_libs       跳过这些依赖库<br><span class="hljs-number">3.</span>ld_path         寻找动态链接库的路径<br><span class="hljs-number">4.</span>backend         后端，比如 blob<br><span class="hljs-number">5.</span>base_addr       基址<br><span class="hljs-number">6.</span>entry_point     入口点<br><span class="hljs-number">7.</span>arch            架构<br></code></pre></td></tr></table></figure><h3 id="Symbolic-Function-Summaries"><a href="#Symbolic-Function-Summaries" class="headerlink" title="Symbolic Function Summaries"></a>Symbolic Function Summaries</h3><p>Project会将外部的call转化为自己的符号执行，angr已经把一整套的外部库函数给模拟为SimProcedures了，</p><p>可以在<code>angr.SIM_PROCEDURES</code>字典访问，键值是库的名字，对象是这个库的函数名字</p><p>如果没有这个外部函数的SimProcedueres:</p><p><code>auto_load_libs</code> is <code>True</code> (default), 执行原来的函数</p><p><code>auto_load_libs</code> is <code>False</code>, 也是模拟执行，但返回一个无约束的状态</p><p><code>use_sim_procedures</code>，这个是<code>angr.Project</code>的参数，如果是False，只会模拟执行此symbols.默认是True</p><p>Hook</p><p><code>proj.hook(addr, hook)</code>, where <code>hook</code> is a SimProcedure instance. You can manage your project’s hooks with <code>.is_hooked</code>, <code>.unhook</code>, and <code>.hooked_by</code>, which should hopefully not require explanation.</p><p>可以指定length参数，来决定hook后跳多少个bytes指令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">stub_func = angr.SIM_PROCEDURES[<span class="hljs-string">&#x27;stubs&#x27;</span>][<span class="hljs-string">&#x27;ReturnUnconstrained&#x27;</span>] <span class="hljs-comment"># this is a CLASS</span><br>proj.hook(<span class="hljs-number">0x10000</span>, stub_func())  <span class="hljs-comment"># hook with an instance of the class</span><br><br>proj.is_hooked(<span class="hljs-number">0x10000</span>)            <span class="hljs-comment"># these functions should be pretty self-explanitory</span><br><span class="hljs-literal">True</span><br>proj.hooked_by(<span class="hljs-number">0x10000</span>)<br>&lt;ReturnUnconstrained&gt;<br><br>proj.unhook(<span class="hljs-number">0x10000</span>)<br><br><span class="hljs-meta">@proj.hook(<span class="hljs-params"><span class="hljs-number">0x20000</span>, length=<span class="hljs-number">5</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_hook</span>(<span class="hljs-params">state</span>):<br>    state.regs.rax = <span class="hljs-number">1</span><br><br>proj.is_hooked(<span class="hljs-number">0x20000</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>angr这样描述hook</p><blockquote><p>Furthermore, you can use <code>proj.hook_symbol(name, hook)</code>, providing the name of a symbol as the first argument, to hook the address where the symbol lives. One very important usage of this is to extend the behavior of angr’s built-in library SimProcedures. Since these library functions are just classes, you can subclass them, overriding pieces of their behavior, and then use your subclass in a hook.</p></blockquote><p>也即我们可以用<code>proj.hook_symbol(name,hook)</code>来替换angr内置的函数，以我们的方式实现</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
      <tag>angr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>miniLCTF2023 maze_aot</title>
    <link href="/2023/05/26/miniLCTF2023%20maze_aot/"/>
    <url>/2023/05/26/miniLCTF2023%20maze_aot/</url>
    
    <content type="html"><![CDATA[<p>一道题学会angr和IDApython,甚至BFS（：</p><span id="more"></span><p>题目流程很简单，输入一个8个十六进制数，依次根据最低位选择一条路径走，走到会终点即可得到flag</p><p>这里是[题目](<a href="https://github.com/XDSEC/miniLCTF_2023/tree/main/Challenges/maze_aot">miniLCTF_2023&#x2F;Challenges&#x2F;maze_aot at main · XDSEC&#x2F;miniLCTF_2023 · GitHub</a>)</p><h2 id="IDApython"><a href="#IDApython" class="headerlink" title="IDApython"></a>IDApython</h2><p>观察迷宫的流程图，会发现是很有规律的，每一个block都有两个successor，根据输入决定前往哪一个successor。还要注意一点，就是会有直接jmp块，需要做个小处理。通过IDApython 提取处迷宫的结构，再用BFS算法去走即可。</p><h3 id="提取迷宫"><a href="#提取迷宫" class="headerlink" title="提取迷宫"></a>提取迷宫</h3><p>大致分为三部分，第一部分是计算每个block的successor，存储为字典形式，这里不区分是普通跳转还是直接jmp跳转</p><p>第二部分是记录直接跳转块</p><p>第三部分是计算普通跳转是通过什么方式去跳，即是jz还是jnz，也是存储为字典形式</p><p>note：在提取迷宫的时候，最好将地址全部转为十进制的整型，否则后面比较会有各种问题（在这卡了好久）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python">start_ea = <span class="hljs-number">0x1500</span><br>end_ea = <span class="hljs-number">0x23D9</span><br><br>func = idaapi.get_func(start_ea)<br>cfg = idaapi.FlowChart(func)<br><br>Maze = <span class="hljs-built_in">dict</span>()<br>JmpMethod = <span class="hljs-built_in">dict</span>()<br>DirJmp = <span class="hljs-built_in">list</span>()<br><span class="hljs-keyword">for</span> block <span class="hljs-keyword">in</span> cfg:<br>    BlockStart = block.start_ea<br>    BlockEnd = block.end_ea<br>    <br>    <span class="hljs-comment"># 初始化一下</span><br>    Maze[BlockStart] = <span class="hljs-built_in">list</span>()<br><br>    <span class="hljs-comment"># 记录每一个块可以去哪</span><br>    <span class="hljs-keyword">for</span> succ <span class="hljs-keyword">in</span> block.succs():<br>        <span class="hljs-comment"># 如果不是直接跳转块，那么直接获取successor的起始地址</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> GetDisasm(succ.start_ea).startswith(<span class="hljs-string">&#x27;jmp&#x27;</span>):<br>            Maze[BlockStart].append(succ.start_ea)<br>        <span class="hljs-comment"># 如果是直接跳转块 那么就获取该汇编语句jmp的地址，并将字符型地址转为整数型存储</span><br>        <span class="hljs-keyword">else</span>:<br>            Maze[BlockStart].append(<span class="hljs-built_in">int</span>(GetDisasm(succ.start_ea)[-<span class="hljs-number">4</span>::],base=<span class="hljs-number">16</span>))<br>    <br>    <span class="hljs-comment"># 记录直接跳转块</span><br>    <span class="hljs-keyword">if</span> GetDisasm(BlockStart).startswith(<span class="hljs-string">&#x27;jmp&#x27;</span>):<br>        DirJmp.append(BlockStart)<br>        <br>    <span class="hljs-comment"># 记录普通跳转块</span><br>    <span class="hljs-keyword">elif</span> BlockStart!=start_ea <span class="hljs-keyword">and</span> BlockStart!=end_ea:<span class="hljs-comment">#这两个不等号是用来掐头去尾，否则下面Dst转化就会有问题</span><br>        JmpMethod[BlockStart] = <span class="hljs-built_in">list</span>()<br>        <span class="hljs-comment">#  这里有一个细节 就是一个block的结束地址 并不是这个block最后一条语句的地址 而是它successor的起始地址</span><br>        <span class="hljs-comment">#  所以这里就获取结束地址的前一条语句 来得到block的最后一条语句</span><br>        <span class="hljs-comment">#  prev_head功能是获取前一条语句 print_insn_mnem是获取操作指令</span><br>        Dst = <span class="hljs-built_in">int</span>(GetDisasm(prev_head(BlockEnd))[-<span class="hljs-number">4</span>::],base=<span class="hljs-number">16</span>)<br>        JmpMethod[BlockStart].append(print_insn_mnem(prev_head(BlockEnd)))<br>        JmpMethod[BlockStart].append(Dst)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Maze:&quot;</span>)<br><span class="hljs-built_in">print</span>(Maze)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;***************************************************************&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;DirJmp:&quot;</span>)<br><span class="hljs-built_in">print</span>(DirJmp)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;***************************************************************&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;JmpMethod:&quot;</span>)<br><span class="hljs-built_in">print</span>(JmpMethod)<br>    <br></code></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>得到迷宫后，就可以用BFS走，DFS应该是走不出来的，因为可能有环的存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 接上文一起</span><br><span class="hljs-keyword">import</span> queue<br><br>start = <span class="hljs-number">0x1500</span><br>end = <span class="hljs-number">0x23d9</span><br>q = queue.Queue()<br>q.put(<span class="hljs-number">0x1500</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">maze_walk</span>():<br>    visited = <span class="hljs-built_in">set</span>()<br>    father = &#123;<span class="hljs-number">0x1500</span>: <span class="hljs-literal">None</span>&#125; <span class="hljs-comment">#用于回溯</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> q.empty():<br>        curr = q.get() <span class="hljs-comment"># 取的同时也会弹出</span><br>        nxs = Maze[curr]<br>        <span class="hljs-keyword">for</span> dirc <span class="hljs-keyword">in</span> nxs:<br>            <span class="hljs-keyword">if</span> dirc <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> visited:<br>                visited.add(dirc)<br>                father[dirc] = curr<br>                q.put(dirc)<br><br>            <span class="hljs-keyword">if</span> dirc == end:<br>                p = [dirc]<br>                <span class="hljs-keyword">while</span> father[dirc] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    dirc = father[dirc]<br>                    p.append(dirc)<br><br>                <span class="hljs-keyword">return</span> p[::-<span class="hljs-number">1</span>] <span class="hljs-comment"># 反转得到由起点-&gt;终点路径</span><br><br><br>path = maze_walk()<br>p = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> path:<br>    <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> DirJmp: <span class="hljs-comment">#如果是jmp跳 那么不理他 下一个</span><br>        p.append(i)<br>p = p[<span class="hljs-number">1</span>:] <span class="hljs-comment">#除去第一个点即0x1500</span><br><br><br>ans = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(p) - <span class="hljs-number">1</span>): <span class="hljs-comment"># 终点不算</span><br>    <span class="hljs-keyword">if</span> JmpMethod[p[i]][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;jnz&#x27;</span> <span class="hljs-keyword">and</span> JmpMethod[p[i]][<span class="hljs-number">1</span>] == p[i + <span class="hljs-number">1</span>]:<br>        ans += <span class="hljs-string">&#x27;1&#x27;</span><br>    <span class="hljs-keyword">if</span> JmpMethod[p[i]][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;jz&#x27;</span> <span class="hljs-keyword">and</span> JmpMethod[p[i]][<span class="hljs-number">1</span>] == p[i + <span class="hljs-number">1</span>]:<br>        ans += <span class="hljs-string">&#x27;0&#x27;</span><br>    <span class="hljs-keyword">if</span> JmpMethod[p[i]][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;jnz&#x27;</span> <span class="hljs-keyword">and</span> JmpMethod[p[i]][<span class="hljs-number">1</span>] != p[i + <span class="hljs-number">1</span>]:<br>        ans += <span class="hljs-string">&#x27;0&#x27;</span><br>    <span class="hljs-keyword">if</span> JmpMethod[p[i]][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;jz&#x27;</span> <span class="hljs-keyword">and</span> JmpMethod[p[i]][<span class="hljs-number">1</span>] != p[i + <span class="hljs-number">1</span>]:<br>        ans += <span class="hljs-string">&#x27;1&#x27;</span><br><br><span class="hljs-comment"># 再反转得到 因为迷宫从输入的最低位开始走的，所以最右边才是起始</span><br>ans = <span class="hljs-built_in">int</span>(ans[::-<span class="hljs-number">1</span>], <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ans))<br><span class="hljs-comment">#  893bddd9aa12789e</span><br></code></pre></td></tr></table></figure><h2 id="Angr"><a href="#Angr" class="headerlink" title="Angr"></a>Angr</h2><p>主要思路就是模拟迷宫的走法，自定义一个ExplorationTechnique,避免路径爆炸的问题，毕竟 2^64次方还是很大的，里面的各种技术细节可以参考下之前的文章（就是因为这题，才写了这些文章 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br><span class="hljs-keyword">import</span> claripy<br><span class="hljs-keyword">from</span> angr <span class="hljs-keyword">import</span> SimState<br><span class="hljs-comment"># 继承ExplorationTechnique类，并重载一些方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Walk</span>(angr.ExplorationTechnique):<br>    <span class="hljs-string">&quot;&quot;&quot;大体思路就是BFS&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,MazeRange:<span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">int</span> ,<span class="hljs-built_in">int</span>],MazeFinal:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        MazeRange:整个迷宫范围，也就是起始地址到结束地址，注意是整个迷宫，不是起始到终点的范围</span><br><span class="hljs-string">        MazeFinal:迷宫终点</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        self._MazeRange = MazeRange<br>        self._MazeFinal = MazeFinal<br>        self._Vistited = <span class="hljs-built_in">set</span>() <span class="hljs-comment">#用于判断是否访问过</span><br>       <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self,simgr:angr.SimulationManager</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        定义并初始化两个stash</span><br><span class="hljs-string">        初始化_Vistited</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        simgr.stashes[<span class="hljs-string">&#x27;visited&#x27;</span>] =[]<br>        simgr.stashes[<span class="hljs-string">&#x27;found&#x27;</span>] =[]<br>        self._Vistited.add(simgr.active[<span class="hljs-number">0</span>].addr)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isInMaze</span>(<span class="hljs-params">self,state:angr.SimState</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> self._MazeRange[<span class="hljs-number">0</span>] &lt;= state.addr &lt; self._MazeRange[<span class="hljs-number">1</span>]<br>    <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">StateSplitter</span>(<span class="hljs-params">self,states:<span class="hljs-built_in">list</span>[angr.SimState]</span>) -&gt; <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">list</span>[angr.SimState],<span class="hljs-built_in">list</span>[angr.SimState]]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        此函数用于分拣State，如果访问过就不要让这个State加入下一次的循环了</span><br><span class="hljs-string">        类似于BFS那个核心要点</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>            _keep =[]<br>            _split =[]<br>            <span class="hljs-keyword">for</span> state <span class="hljs-keyword">in</span> states:<br>                <span class="hljs-keyword">if</span> self.isInMaze(state): <span class="hljs-comment">#判断是否在迷宫范围内是因为走迷宫的时候会call &#x27;step&#x27; 函数，那个我们不处理</span><br>                    <span class="hljs-keyword">if</span> state.addr <span class="hljs-keyword">in</span> self._Vistited:<br>                        _split.append(state)<br>                    <span class="hljs-keyword">else</span>:<br>                        self._Vistited.add(state.addr)<br>                        _keep.append(state)<br>                <span class="hljs-keyword">else</span>:<br>                    _keep.append(state) <span class="hljs-comment"># &#x27;step&#x27;或者其他非迷宫内部的state我们都要执行</span><br><br>            <span class="hljs-keyword">return</span> _keep,_split<span class="hljs-comment"># 这里的返回顺序不能改，前面的是保留的，后面的是舍弃的</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isEnd</span>(<span class="hljs-params">self,state:SimState</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>            <span class="hljs-keyword">return</span> state.addr == self._MazeFinal <span class="hljs-comment"># 判断是否到终点了</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self,simgr:angr.SimulationManager,stash :<span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;active&#x27;</span>,**kwargs</span>) -&gt; angr.SimulationManager:<br>        <span class="hljs-comment"># 模拟执行</span><br>        simgr.step(stash=stash,**kwargs)<br><br>        <span class="hljs-comment"># 筛选用于下一次执行的state</span><br>        simgr.split(stash_splitter = self.StateSplitter,from_stash = <span class="hljs-string">&#x27;active&#x27;</span>,to_stash = <span class="hljs-string">&#x27;visited&#x27;</span>)<br><br>        <span class="hljs-comment"># 将到终点的state存下来</span><br>        simgr.move(from_stash = <span class="hljs-string">&#x27;active&#x27;</span>,to_stash = <span class="hljs-string">&#x27;found&#x27;</span>,filter_func = self.isEnd)<br><br>        <span class="hljs-keyword">return</span> simgr<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">complete</span>(<span class="hljs-params">self,simgr:angr.SimulationManager</span>):<br>        <span class="hljs-comment"># 定义找到终点就结束</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(simgr.found)<br>    <br><br><span class="hljs-comment"># 装载 设定基址为0</span><br>proj = angr.Project(<span class="hljs-string">&quot;./maze&quot;</span>,auto_load_libs = <span class="hljs-literal">False</span>,main_opts=&#123;<span class="hljs-string">&#x27;base_addr&#x27;</span>: <span class="hljs-number">0</span>&#125;)<br><br><span class="hljs-comment"># 找到这几个对象</span><br>SymMazeWalk = proj.loader.find_symbol(<span class="hljs-string">&quot;maze_walk&quot;</span>)<br>SymMazeFinal = proj.loader.find_symbol(<span class="hljs-string">&quot;maze_final&quot;</span>)<br><br>SymKey = proj.loader.find_symbol(<span class="hljs-string">&quot;key&quot;</span>)<br>SymSteps = proj.loader.find_symbol(<span class="hljs-string">&quot;steps&quot;</span>)<br><br>KeyValue = claripy.BVS(<span class="hljs-string">&quot;SymKey&quot;</span>,<span class="hljs-number">64</span>)<br><br><span class="hljs-comment"># 从 maze_walk 开始</span><br>State = proj.factory.call_state(SymMazeWalk.rebased_addr,prototype = <span class="hljs-string">&#x27;void f()&#x27;</span>)<br>State.options.add(angr.sim_options.ZERO_FILL_UNCONSTRAINED_REGISTERS)<br><br><span class="hljs-comment"># 因为我们跳过了main函数，没有执行输入 所以要自己把输入给存进内存</span><br>State.memory.store(SymKey.rebased_addr,KeyValue)<br>State.memory.store(SymSteps.rebased_addr,KeyValue)<br><br><span class="hljs-comment"># 实例化我们的Walk</span><br>tech = Walk(MazeRange=(SymMazeWalk.rebased_addr,SymMazeWalk.rebased_addr + SymMazeWalk.size),<br>            MazeFinal=SymMazeFinal.rebased_addr)<br><br><span class="hljs-comment"># 准备执行</span><br>Simgr = proj.factory.simgr(State)<br><span class="hljs-comment"># 使用我们的搜索方式</span><br>Simgr.use_technique(tech)<br><br><span class="hljs-comment"># 开始跑 直到找到可以达终点的state</span><br>Simgr.run()<br><span class="hljs-comment"># 移除我们的搜索方式 准备继续执行</span><br>Simgr.remove_technique(tech)<br><br><span class="hljs-comment"># 从我们找到那个state开始执行</span><br>SolveState = proj.factory.simgr(Simgr.found[<span class="hljs-number">0</span>])<br>SolveState.run()<br><span class="hljs-comment"># 执行到最后得到输出 即为flag</span><br><span class="hljs-built_in">print</span>(SolveState.deadended[<span class="hljs-number">0</span>].posix.dumps(<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># miniLctf&#123;YOU_AR3_$0_GOOD_4T_SOLV1NG_MAZE&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>recurrence</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
      <tag>angr</tag>
      
      <tag>idapython</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ExplorationTechnique</title>
    <link href="/2023/05/26/ExplorationTechniques/"/>
    <url>/2023/05/26/ExplorationTechniques/</url>
    
    <content type="html"><![CDATA[<p>About <a href="https://docs.angr.io/en/latest/_modules/angr/exploration_techniques.html#ExplorationTechnique">ExplorationTechnique</a></p><span id="more"></span><p>首先，这也是一个类。先来看看angr对这个类的说明</p><blockquote><p><em>An technique is a set of hooks for a simulation manager that assists in the implementation of new techniques in symbolic exploration.</em>      </p><p><em>Any number of these methods may be overridden by a subclass.</em> <em>To use an exploration technique, call <code>simgr.use_technique</code> with an *instance* of the technique.</em></p></blockquote><p>就是说这个technique是一系列hook的集合，可以更好帮助我们符号执行。而且这个类里面的方法都可以使用子类重写，用一个实例来调用<code>simgr.use_technique</code> </p><p>其实这个类就是帮我们把符号执行所必须的几个步骤给我们打包起来，然后让我们重载里面的步骤，新生成一个子类，然后按照这子类里面规定的方法去符号执行</p><p>这是整个类的定义以及相关成员函数的说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExplorationTechnique</span>:<br><br>    <span class="hljs-comment"># 主要hook函数</span><br>    _hook_list = (<span class="hljs-string">&quot;step&quot;</span>, <span class="hljs-string">&quot;filter&quot;</span>, <span class="hljs-string">&quot;selector&quot;</span>, <span class="hljs-string">&quot;step_state&quot;</span>, <span class="hljs-string">&quot;successors&quot;</span>)<br><br>    <span class="hljs-comment"># 得到被重写的hook函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_hooks</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> &#123;name: <span class="hljs-built_in">getattr</span>(self, name) <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> self._hook_list <span class="hljs-keyword">if</span> self._is_overriden(name)&#125;<br>    <br><span class="hljs-comment"># 判断哪些函数被重写</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_is_overriden</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(self, name).__code__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">getattr</span>(ExplorationTechnique, name).__code__<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&quot;project&quot;</span>):<br>            self.project: angr.project.Project = <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 这确实就是一个空函数，专门提供给使用者来初始化自己所要的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self, simgr</span>):<br>        <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self, simgr, stash=<span class="hljs-string">&quot;active&quot;</span>, **kwargs</span>): <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">         用来hook step函数，最后应该调用simgr.step以便真正执行</span><br><span class="hljs-string">         原本的step是往下执行一步，去到后继block</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        simgr.step(stash=stash, **kwargs)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">self, simgr, state, **kwargs</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">          决定该state要被移去哪一个stash</span><br><span class="hljs-string">          </span><br><span class="hljs-string">          如果说这个state要被filter的话，就把这个state要被移去的stash名字返回</span><br><span class="hljs-string">          如果想在filter之前对state做一些改变，就返回一个stash的元组，并修改state</span><br><span class="hljs-string">          </span><br><span class="hljs-string">          这和step里的filter_fun起到的作用一样的</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> simgr.<span class="hljs-built_in">filter</span>(state, **kwargs)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">selector</span>(<span class="hljs-params">self, simgr, state, **kwargs</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        决定该state是否要参与进这个step round，也就是如果这个state要进入的话，就返</span><br><span class="hljs-string">        回True否则返回False</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        这个step里的selector_fun起到的作用是一样的</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> simgr.selector(state, **kwargs)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">step_state</span>(<span class="hljs-params">self, simgr, state, **kwargs</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        决定该state的successor应该放去哪个块。结果应该是一个stash到successor列表的字典映射</span><br><span class="hljs-string">        如[&quot;active:[succ1,succ2]&quot;]</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        note:该函数的优先级高于filter filter是作用于当前返回的state</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> simgr.step_state(state, **kwargs)<br><br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">successors</span>(<span class="hljs-params">self, simgr, state, **kwargs</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        在进入一个state时调用，返回一个SimSuccssors对象</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> simgr.successors(state, **kwargs)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">complete</span>(<span class="hljs-params">self, simgr</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        返回当前simgr是否到达 &quot;completed&quot; state</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        该方法不是hook的对象，也不应该直接调用此方法，而是应该自己决定返回True或者False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>setup</code> 初始化</p><p><code>step</code> hook步入</p><p><code>filter</code>决定该state放去哪 即丢去哪</p><p><code>selector</code> 决定该state是否执行 </p><p><code>step_state</code> 决定successors放去哪个stash</p><p><code>successors</code> 在进入一个state时调用</p><p><code>complete</code> 是否全部完成</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
      <tag>angr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Factory SimManger State</title>
    <link href="/2023/05/24/Factory%20SimManger%20State/"/>
    <url>/2023/05/24/Factory%20SimManger%20State/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.angr.io/en/latest/_modules/angr/factory.html">facntory</a> <a href="https://docs.angr.io/en/latest/_modules/angr/sim_manager.html#SimulationManager">SimManger</a> State</p><span id="more"></span><p>一般使用angr时，都会以以下几句开头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br>proj = angr.Project(<span class="hljs-string">&#x27;examples/fauxware/fauxware&#x27;</span>, auto_load_libs=<span class="hljs-literal">False</span>)<br>state = proj.factory.entry_state()<br>simgr = proj.factory.simgr(state)<br></code></pre></td></tr></table></figure><p>现在就来看看<code>factory</code>都究竟是个啥</p><p>首先factory是一个类，但是它更像是一个工具类，帮助我们完成一些事情，我们就可以简单调用里面的方法。比如我们想要初始化一个入口函数的<code>state</code>,那么我们就可以调用<code>factory</code>里面的<code>entry_state()</code>,就不用自己再去关心那细节。</p><p>现在就来看看里面还有哪些方法</p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="blank-state-self-kwargs"><a href="#blank-state-self-kwargs" class="headerlink" title="blank_state(self, **kwargs)"></a>blank_state(self, **kwargs)</h3><p>调用此方法，会返回一个几乎没有初始化的state对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">blank_state</span>(<span class="hljs-params">self,**kwargs</span>)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Returns a mostly-uninitialized state object. All parameters are optional.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        :param addr:            State 开始的地址</span><br><span class="hljs-string">        :param initial_prefix:  如果提供，所有的符号寄存器都会有一个以此为前缀字符串的符号值</span><br><span class="hljs-string">        :param fs:              A dictionary of file names with associated preset SimFile objects.</span><br><span class="hljs-string">        :param concrete_fs:     bool describing whether the host filesystem should be consulted when opening files.</span><br><span class="hljs-string">        :param chroot:          A path to use as a fake root directory, Behaves similarly to a real chroot. Used only when concrete_fs is set to True.</span><br><span class="hljs-string">        :param kwargs:          Any additional keyword args will be passed to the SimState constructor.</span><br><span class="hljs-string">        :return:                返回一个空 state</span><br><span class="hljs-string">        :rtype:                 返回类型 SimState</span><br><span class="hljs-string"> &quot;&quot;&quot;</span><br> <span class="hljs-keyword">return</span> self.project.simos.state_blank<br></code></pre></td></tr></table></figure><h3 id="entry-state-self-kwargs"><a href="#entry-state-self-kwargs" class="headerlink" title="entry_state(self, **kwargs)"></a>entry_state(self, **kwargs)</h3><p>调用此方法，返回一个起始地址的<code>state</code></p><h3 id="full-init-state-self-kwargs"><a href="#full-init-state-self-kwargs" class="headerlink" title="full_init_state(self, **kwargs)"></a>full_init_state(self, **kwargs)</h3><blockquote><p><em>Very much like :meth:<code>entry_state()</code>, except that instead of starting execution at the program entry point,</em>        <em>execution begins at a special SimProcedure that plays the role of the dynamic loader, calling each of the</em>        <em>initializer functions that should be called before execution reaches the entry point.</em>         <em>It can take any of the arguments that can be provided to <code>entry_state</code>, except for <code>addr</code>.</em></p></blockquote><p>意思是，这个方法拥有以上的所有参数除了addr，因为这个方法是先于符号执行的，它的作用是初始化，调用哪些所有的初始化函数</p><h3 id="call-state-self-addr-args-kwargs"><a href="#call-state-self-addr-args-kwargs" class="headerlink" title="call_state(self, addr, *args, **kwargs)"></a>call_state(self, addr, *args, **kwargs)</h3><p>很显然是一个创建call到某个函数的state，它的参数</p><blockquote><p><em>Returns a state object initialized to the start of a given function, as if it were called with given parameters.</em>         </p><p><em>:param addr:            The address the state should start at instead of the entry point.</em>        </p><p><em>:param args:            Any additional positional arguments will be used as arguments to the function call.</em> </p></blockquote><p>返回一个以给定函数起初地址的<code>state</code>，换句话说提供<code>addr</code>,它将以此创建一个<code>state</code>,而不再是entry point。它也可以通过<code>args</code>来传递所call的函数参数</p><h2 id="Simulation-Manager"><a href="#Simulation-Manager" class="headerlink" title="Simulation Manager"></a>Simulation Manager</h2><h3 id="simgr-simulation-manager-self-thing-Optional-Union-List-SimState-SimState-x3D-None-kwargs"><a href="#simgr-simulation-manager-self-thing-Optional-Union-List-SimState-SimState-x3D-None-kwargs" class="headerlink" title="simgr simulation_manager( self, thing: Optional[Union[List[SimState], SimState]] &#x3D; None,**kwargs)"></a>simgr simulation_manager( self, <strong>thing</strong>: Optional[Union[List[SimState], SimState]] &#x3D; None,**kwargs)</h3><blockquote><p><em>Constructs a new simulation manager.</em>         </p><p><em>:param thing: What to put in the new SimulationManager’s active stash (either a SimState   or a list of</em>  <em>SimStates).</em> </p><p><em>:param kwargs:  Any additional keyword arguments will be passed to the SimulationManager                        constructor</em>        </p><p><em>:returns:               The new SimulationManager</em>        </p><p><em>:rtype:                 angr.sim_manager.SimulationManager</em> </p></blockquote><p>这个方法也很常用，但是它不再是创建和返回state对象，而是利用state对象创建一个simulation manager对象并返回。它的参数就是接受一个state列表或者单独一个state，并把他们放进stash的active里面。如果什么参数也不传，那么它就默认以entry_point为state创建。</p><p>那么这个<code>simulation manager</code>对象是个啥呢？</p><h3 id="SimulationManager"><a href="#SimulationManager" class="headerlink" title="SimulationManager"></a>SimulationManager</h3><p>angr在[文档](<a href="https://docs.angr.io/en/latest/_modules/angr/sim_manager.html#SimulationManager">angr.sim_manager - angr documentation</a>)里面这样评论<em>The Simulation Manager is the future future.</em></p><p>SimulationManager 也是angr里面的一个类。这个类的功能就是帮助我们根据state的stash来管理state，可以往下step，可以过滤filter，也可以融合merge。可以通过属性值来直接获取stash，比如<code>.active</code>,也可以用一些前缀比如<code>mp_</code>,那么就可以<code>mp_active</code>,同理<code>one_</code>.</p><p>这是它的一些成员</p><blockquote><p><em>:param project:           A Project instance.</em>    </p><p><em>:type project:              angr.project.Project</em>   </p><p> <em>:param stashes:</em>           一个字典用于存储stash   </p><p><em>:param active_states:   Active states to seed the “active” stash with.</em>    </p><p><em>:param hierarchy:</em>         一个StateHierarchy对象，用于追踪state之间关系</p><p> <em>:param resilience:</em>        收集error的集合    </p><p><em>:param save_unsat:</em>       如果为True，则保留unsat的state，而不是直接丢掉 </p><p><em>:param auto_drop:</em>        存放直接丢弃的stash的名字</p><p><em>:param completion_mode:</em>     描述exploretion techniques的函数</p><p> <em>:param techniques:</em> 需要预先设定exploretion tech的列表    </p><p>……</p></blockquote><p>当然里面也有很多的方法，最重要的是<code>step</code> ,<code>explore</code>,<code>use_technique</code>三个方法</p><p>看看它的构造函数，通过初始化函数就能这些成员有一个更直观的了解</p><h4 id="init"><a href="#init" class="headerlink" title="__init__"></a>__init__</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        project,</span><br><span class="hljs-params">        active_states=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        stashes=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        hierarchy=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        resilience=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        save_unsat=<span class="hljs-literal">False</span>,</span><br><span class="hljs-params">        auto_drop=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        errored=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        completion_mode=<span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">        techniques=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        suggestions=<span class="hljs-literal">True</span>,</span><br><span class="hljs-params">        **kwargs,</span><br><span class="hljs-params">    </span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        self._project = project<br>        self.completion_mode = completion_mode<br>        self._errored = []<br>        self._lock = PicklableLock()<br><span class="hljs-comment">#  这里就可以放入自己的stash</span><br>        <span class="hljs-keyword">if</span> stashes <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            stashes = self._create_integral_stashes()<br>        self._stashes: DefaultDict[<span class="hljs-built_in">str</span>, <span class="hljs-type">List</span>[<span class="hljs-string">&quot;SimState&quot;</span>]] = stashes<br>        self._hierarchy = StateHierarchy() <span class="hljs-keyword">if</span> hierarchy <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> hierarchy<br>        self._save_unsat = save_unsat<br>        self._auto_drop = &#123;<br>            SimulationManager.DROP,<br>        &#125;<br>        self._techniques = []<br><br>        <span class="hljs-keyword">if</span> resilience <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._resilience = (AngrError, SimError, claripy.ClaripyError)<br>        <span class="hljs-keyword">elif</span> resilience <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>            self._resilience = (<br>                AngrError,<br>                SimError,<br>                claripy.ClaripyError,<br>                KeyError,<br>                IndexError,<br>                TypeError,<br>                ValueError,<br>                ArithmeticError,<br>                MemoryError,<br>            )<br>        <span class="hljs-keyword">elif</span> resilience <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>            self._resilience = ()<br>        <span class="hljs-keyword">else</span>:<br>            self._resilience = <span class="hljs-built_in">tuple</span>(resilience)<br><br>        <span class="hljs-keyword">if</span> suggestions:<br>            self.use_technique(Suggestions())<br><br>        <span class="hljs-comment"># 8&lt;----------------- Compatibility layer -----------------</span><br><br>        <span class="hljs-keyword">if</span> auto_drop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> kwargs.pop(<span class="hljs-string">&quot;save_unconstrained&quot;</span>, <span class="hljs-literal">True</span>):<br>            self._auto_drop |= &#123;<span class="hljs-string">&quot;unconstrained&quot;</span>&#125;<br><br>        <span class="hljs-keyword">if</span> kwargs.pop(<span class="hljs-string">&quot;veritesting&quot;</span>, <span class="hljs-literal">False</span>):<br>            self.use_technique(Veritesting(**kwargs.get(<span class="hljs-string">&quot;veritesting_options&quot;</span>, &#123;&#125;)))<br>        kwargs.pop(<span class="hljs-string">&quot;veritesting_options&quot;</span>, &#123;&#125;)<br><br>        threads = kwargs.pop(<span class="hljs-string">&quot;threads&quot;</span>, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> threads <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.use_technique(Threading(threads))<br><br>        <span class="hljs-keyword">if</span> kwargs:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;Unexpected keyword arguments: &quot;</span> + <span class="hljs-string">&quot; &quot;</span>.join(kwargs))<br>        <span class="hljs-comment"># ------------------ Compatibility layer ----------------&gt;8</span><br><br>        <span class="hljs-keyword">if</span> auto_drop:<br>            self._auto_drop |= <span class="hljs-built_in">set</span>(auto_drop)<br><br>        <span class="hljs-keyword">if</span> errored <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self._errored.extend(errored)<br><br>        <span class="hljs-keyword">if</span> active_states:<br>            self._store_states(<span class="hljs-string">&quot;active&quot;</span>, active_states)<br><br>        <span class="hljs-keyword">if</span> techniques:<br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> techniques:<br>                self.use_technique(t)<br></code></pre></td></tr></table></figure><h4 id="step"><a href="#step" class="headerlink" title="step"></a>step</h4><p>看看它的参数即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        stash=<span class="hljs-string">&quot;active&quot;</span>,</span><br><span class="hljs-params">        target_stash=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        n=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        selector_func=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        step_func=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        error_list=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        successor_func=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        until=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        filter_func=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        **run_args,</span><br><span class="hljs-params">    </span>):<br>    <br></code></pre></td></tr></table></figure><blockquote><p><em>stash</em> : 需要step的stash名字，默认是active</p><p><em>target_stash</em> :  将结果放入哪个stash</p><p><em>n</em> :    如果<code>until</code>是NULL的话，那么会一直执行n步</p><p><em><strong>selector_fun</strong></em> : 接收一个以state为参数、返回类型为布尔的函数，如果返回为True，那么执行该                                                                                               state，否则保持原样</p><p><em><strong>step_fun</strong></em> :   接收一个以SimulationManager为参数并返回SimulantionManager的函数，每一次调用<code>step()</code>时，都会调用该函数，但该函数里面不应该有<code>step(</code>)</p><p><em>error_list</em> :一个list来存储<code>ErroredState</code></p><p><em>successor_fun</em> :接收一个以state为参数并返回它后继的函数</p><p>until：  接收一个以SimulationManger为参数并返回布尔值的函数，一直执行到返回为True</p><p><em>filter_func</em> ： 接收一个以state为参数并返回该state要移去哪个stash名字的函数</p></blockquote><p>现在的angr中<code>n</code>和<code>until</code>已经移植到<code>run()</code>中，用法相同</p><h4 id="use-technique"><a href="#use-technique" class="headerlink" title="use_technique"></a>use_technique</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"> Use an exploration technique with this SimulationManager.</span><br><span class="hljs-string"></span><br><span class="hljs-string"> Techniques can be found in :mod:`angr.exploration_techniques`.</span><br><span class="hljs-string"></span><br><span class="hljs-string">:param tech:    一个ExplorationTechnique对象，用以控制该SimluationManger行为</span><br><span class="hljs-string">:type tech:     ExplorationTechnique           （note：ExplorationTechnique也是angr的一个比较重要的类）</span><br><span class="hljs-string">:return:        The technique that was added, for convenience</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(tech, ExplorationTechnique):<br>            <span class="hljs-keyword">raise</span> SimulationManagerError<br><br>        <span class="hljs-comment"># <span class="hljs-doctag">XXX:</span> as promised</span><br>        tech.project = self._project<br>        tech.setup(self)<br><br>        HookSet.install_hooks(self, **tech._get_hooks())<br>        self._techniques.append(tech)<br>        <span class="hljs-keyword">return</span> tech<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>State是一个模拟状态，里面包含很多值，各种寄存器，内存以及几乎所有可以变得值，它是大多数函数的参数。</p><p>我们想要得到一个state，可以调用factory里的关于state的方法。还可以使用得到的state的对象以及factory.simgr方法得到一个SimManger对象。factory相当于一个工具箱，封装angr内部许多常用方法，方便我们调用，就不需要自己手动操作了。</p><p>当我们拥有一个state的时候，就可以把它丢给SimManger了，我们可以到一个SimManger的对象，这一步相当于把这个state拉伸进内存，得到更多有效信息，就可以开始正式执行了，而且我们还可以设定各种执行方式，是只走一步还是一直走到尽头?中间状态要怎么处理？以什么方式走？等等</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
      <tag>angr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simulation Managers</title>
    <link href="/2023/05/24/Simulation-Managers/"/>
    <url>/2023/05/24/Simulation-Managers/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.angr.io/en/latest/core-concepts/pathgroups.html#simulation-managers">Stepping Stash-Management Simple-Exploration Exploration-Techniques</a></p><span id="more"></span><blockquote><p>The most important control interface in angr is the SimulationManager, which allows you to control symbolic execution over groups of states simultaneously, applying search strategies to explore a program’s state space. Here, you’ll learn how to use it.</p></blockquote><p>概括：angr里面最重要的控制接口就是<code>SimulationManager</code>,可以以此同时控制不同的<code>states</code>符号执行，我们也可以以此来执行我们的搜索策略</p><blockquote><p>Simulation managers let you wrangle multiple states in a slick way. States are organized into “stashes”, which you can step forward, filter, merge, and move around as you wish. This allows you to, for example, step two different stashes of states at different rates, then merge them together. The default stash for most operations is the <code>active</code> stash, which is where your states get put when you initialize a new simulation manager.</p></blockquote><p>概括：我们可以用用<code>Simulation Managers</code>来管理多个<code>states</code>,<code>States</code>又是由<code>stashes</code>组成，这些<code>stashes</code>我们可以步入、过滤、融合甚至移到另一个<code>stashes</code>,对于绝大多数的<code>stashes</code>都是<code>active</code></p><p>note: 这里一直说的<code>stashes</code>其实就是一种状态标志，意味这个block是否还能继续走下去，比如说一个block是<code>active</code>的，那么它就还有后继而且还能继续往下执行。所以当我们初始丢给<code>Simulation Manager</code>的state应该是<code>active</code>的，这样它<code>Simulation Manager</code>才会为我们模拟执行</p><h2 id="Stepping"><a href="#Stepping" class="headerlink" title="Stepping"></a>Stepping</h2><p>一个简单的demo</p><p>我们使用<code>.step()</code>来让当前的state执行一步，去到下一个block。demo中给出了两个block的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br>proj = angr.Project(<span class="hljs-string">&#x27;examples/fauxware/fauxware&#x27;</span>, auto_load_libs=<span class="hljs-literal">False</span>)<br>state = proj.factory.entry_state()<br>simgr = proj.factory.simgr(state)<br>simgr.active<br>[&lt;SimState @ <span class="hljs-number">0x400580</span>&gt;]<br><br>simgr.step()<br>simgr.active<br>[&lt;SimState @ <span class="hljs-number">0x400540</span>&gt;]<br></code></pre></td></tr></table></figure><p>你一定想问，那如果一个state的后继不止有一个呢？答案是<code>.step()</code>都会执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Step until the first symbolic branch</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(simgr.active) == <span class="hljs-number">1</span>:     <span class="hljs-comment">#只有当前处于active的数量为1，才往下执行</span><br><span class="hljs-meta">... </span>   simgr.step()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">2</span> active&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active<br>[&lt;SimState @ <span class="hljs-number">0x400692</span>&gt;, &lt;SimState @ <span class="hljs-number">0x400699</span>&gt;]<br><br><span class="hljs-comment"># Step until everything terminates</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.run()<br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">3</span> deadended&gt;<br></code></pre></td></tr></table></figure><p>如果我们不关心中间过程，只希望它能一直跑下去，直到再也没有后继块可以执行，那么我们可以用.<code>run()</code></p><p>现在我们使用了<code>.run()</code>得到最终的state，它有三个<code>stash</code>,并且都是<code>deadended</code>状态，也就是跑不动了</p><h2 id="Stash-Management"><a href="#Stash-Management" class="headerlink" title="Stash Management"></a>Stash Management</h2><p>我们可以用<code>.move()</code>来转移状态，它有三个参数<code>from_stash</code>,<code>to_statsh</code>,以及一个可选参数<code>filter_func</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">simgr.move(from_stash=<span class="hljs-string">&#x27;deadended&#x27;</span>, to_stash=<span class="hljs-string">&#x27;authenticated&#x27;</span>, filter_func=<span class="hljs-keyword">lambda</span> s: <span class="hljs-string">b&#x27;Welcome&#x27;</span> <span class="hljs-keyword">in</span> s.posix.dumps(<span class="hljs-number">1</span>))<br>simgr<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">2</span> authenticated, <span class="hljs-number">1</span> deadended&gt;<br></code></pre></td></tr></table></figure><p>这个demo让我们把输出含有<code>Welcome</code>的state转移到<code>authenticated</code>，也就是说<code>authenticated</code>里的state都含有<code>Welcome</code></p><p>每一个<code>stash</code>都是一个列表，我们可以用常规的去索引，也可以用其他方法。如果我们加一个前缀<code>one_</code>那么我们就会访问这个<code>stash</code>的第一个元素，如果用<code>mp_</code>就可以同时访问全部，关于<code>mp_</code>这有一个<a href="https://github.com/zardus/mulpyplexer">说明</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> simgr.deadended + simgr.authenticated:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(s.addr))<br><span class="hljs-number">0x1000030</span><br><span class="hljs-number">0x1000078</span><br><span class="hljs-number">0x1000078</span><br><br>simgr.one_deadended<br>&lt;SimState @ <span class="hljs-number">0x1000030</span>&gt;<br>simgr.mp_authenticated<br>MP([&lt;SimState @ <span class="hljs-number">0x1000078</span>&gt;, &lt;SimState @ <span class="hljs-number">0x1000078</span>&gt;])<br>simgr.mp_authenticated.posix.dumps(<span class="hljs-number">0</span>)<br>MP([<span class="hljs-string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#x27;</span>,<br>    <span class="hljs-string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80@\x80@\x00&#x27;</span>])<br></code></pre></td></tr></table></figure><blockquote><p>Of course, <code>step</code>, <code>run</code>, and any other method that operates on a single stash of paths can take a <code>stash</code> argument, specifying which stash to operate on.</p></blockquote><p>也就是所有的<code>step</code>,<code>run</code>方法都可以接受一个<code>stash</code>参数，来决定执行哪一个</p><h3 id="Stash-types"><a href="#Stash-types" class="headerlink" title="Stash types"></a>Stash types</h3><p>You can use stashes for whatever you like, but there are a few stashes that will be used to categorize some special kinds of states. These are:</p><table><thead><tr><th>Stash</th><th>Description</th></tr></thead><tbody><tr><td>active</td><td>可执行的</td></tr><tr><td>deadended</td><td>再也无法执行的，可能是因为无法到达，没有后继等</td></tr><tr><td>pruned</td><td>（不太确定）当使用<code>LAZY_SOLVES</code>时，states不会再检查可满足性，当一个state发现是<code>unsat</code>时，这个states路径上的所有states都会变成<code>pruned</code></td></tr><tr><td>unconstrained</td><td>如果 <code>save_unconstrained</code> 传递给SimelationManager constructor, 那些无约束的就时<code>unconstrained</code></td></tr><tr><td>unsat</td><td>如果 <code>save_unsat</code> 传递给SimelationManager constructor, 那些无解的就时<code>unsat</code>,比如要求输入同时满足即是’AAAA’又是’BBBB’</td></tr></tbody></table><h2 id="Simple-Exploration"><a href="#Simple-Exploration" class="headerlink" title="Simple Exploration"></a>Simple Exploration</h2><p>符号执行很普遍的用法是找到一个可以到达某个地址的states，而忽略其他所有的states，angr提供<code>.explore()</code>来方便执行。</p><p>当我们使用<code>.explore()</code>方法时，它可以接受两个参数<code>find</code>以及<code>avoid</code>。其中<code>find</code>可以是一个地址，一个列表，一个以<code>state</code>为参数返回某些值的函数，当任何一个<code>active</code>符合<code>find</code>的要求，那么它就会被放入<code>found</code>stash里面，同时停止执行，<code>avoid</code>一样，不过是放入<code>avoided</code>stash里面，然后继续符号执行。<code>num_find</code>可以决定找多少个<code>found</code>，简单demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 装载</span><br>proj = angr.Project(<span class="hljs-string">&#x27;examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a&#x27;</span>)<br><span class="hljs-comment"># 创建对象</span><br>simgr = proj.factory.simgr()<br><span class="hljs-comment"># 开始符号执行 搜索</span><br>simgr.explore(find=<span class="hljs-keyword">lambda</span> s: <span class="hljs-string">b&quot;Congrats&quot;</span> <span class="hljs-keyword">in</span> s.posix.dumps(<span class="hljs-number">1</span>))<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active, <span class="hljs-number">1</span> found&gt;<br><span class="hljs-comment"># 找到一个 利用索引的方式得到该state</span><br>s = simgr.found[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 查看该state的输出</span><br><span class="hljs-built_in">print</span>(s.posix.dumps(<span class="hljs-number">1</span>))<br>Enter password: Congrats!<br><span class="hljs-comment"># 查看该state的输入</span><br>flag = s.posix.dumps(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(flag)<br>g00dJ0B!<br></code></pre></td></tr></table></figure><h2 id="Exploration-Techniques"><a href="#Exploration-Techniques" class="headerlink" title="Exploration Techniques"></a>Exploration Techniques</h2><p>angr内置了很多种的搜索算法，但是我们也可以自己写一个搜索算法，并通过<code>simgr.use_technique(tech)</code>调用，这里的<code>tech</code>是<code>ExplorationTechnique</code>子类。后面会再详谈，这里先列出angr内置的一些搜索算法</p><ul><li><em>DFS</em>: 深度优先，只会让一个state为active，把其他的放进<code>deferred</code>stash</li><li><em>Explorer</em>: 实现<code>.explore()</code>,可以使用<code>find</code>,<code>avoid</code>方法</li><li><em>LengthLimiter</em>:最长路径截断</li><li><em>LoopSeer</em>: 如果可能在一个循环里面，放入<code>spining</code>stash,直到其他可达路径都走完</li><li><em>ManualMergepoint</em>: 标记一个地址作为merge点，当一个stata到达此处时将其挂起，当其他state在某个时间内到达这个点时会被merge</li><li><em>Memory</em>：在<code>.step()</code>之间监视内存释放&#x2F;使用情况,如果内存释放&#x2F;使用得少的话，停止探索</li><li><em>Oppologist</em>: 当angr遇到一个不支持的指令的时候，会具体化所有的输入，并使用unicorn引擎来单独模拟这条指令，使得可以继续符号执行</li><li><em>Spiller</em>: 当有太多states处于active状态时，这可以把一些states放进磁盘中，使得内存开销比较小</li><li><em>Threading</em>: 使用多线程并行处理，但由于python全局变量线程锁的原因，这并不会有多大提升。但是如果在angr的native-code依赖（z3，unicorn，libvex）上花太多时间可以考虑这项技术</li><li><em>Tracer</em>：可以动态追踪资源</li><li><em>Veritesting</em>:自动识别有用的可合并点，使用<code>veritesting=True</code>来启用，这会提高搜索效率，但与其他算法配合得并不是很好</li></ul><p>Look at the API documentation for the <a href="https://docs.angr.io/en/latest/api.html#angr.sim_manager.SimulationManager"><code>SimulationManager</code></a> and <a href="https://docs.angr.io/en/latest/api.html#angr.exploration_techniques.ExplorationTechnique"><code>ExplorationTechnique</code></a> classes for more information.</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
      <tag>angr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Core Concept</title>
    <link href="/2023/05/23/Core-Concept/"/>
    <url>/2023/05/23/Core-Concept/</url>
    
    <content type="html"><![CDATA[<p>最基础的angr，原文档链接<a href="https://docs.angr.io/en/latest/core-concepts/toplevel.html">在此</a></p><span id="more"></span><h2 id="To-start-proj-angr-Project-39-ELF-path-39"><a href="#To-start-proj-angr-Project-39-ELF-path-39" class="headerlink" title="To start: proj = angr.Project(&#39;/ELF_path&#39;)"></a><em>To start</em>: <code>proj = angr.Project(&#39;/ELF_path&#39;)</code></h2><p>We can do these things with <code>proj</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> Check arch: proj.arch <span class="hljs-comment">#查看架构</span><br><span class="hljs-number">2.</span> Check entry: proj.entry <span class="hljs-comment">#查看程序入口</span><br><span class="hljs-number">3.</span> See Name : proj.filename <span class="hljs-comment">#查看文件名字</span><br></code></pre></td></tr></table></figure><h2 id="To-Load-proj-loader"><a href="#To-Load-proj-loader" class="headerlink" title="To Load: proj.loader"></a><em>To Load</em>: <code>proj.loader</code></h2><p>We can do these things with <code>proj.loader</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> See Shared_objects: proj.loader.shared_objects<br><span class="hljs-number">2.</span> See min_addr: proj.loader.min_addr<br><span class="hljs-number">3.</span> see max_addr: proj.loader.max_addr<br><span class="hljs-number">4.</span> See main_object: proj.loader.main_object <span class="hljs-comment"># 主要对象</span><br><span class="hljs-number">5.</span> Check the binary have an executable stack: proj.loader.main_object.execstack<br><span class="hljs-number">6.</span> Check this binary position-independent : proj.loader.main_object.pic<br></code></pre></td></tr></table></figure><h2 id="The-Factory"><a href="#The-Factory" class="headerlink" title="The Factory"></a><em>The Factory</em></h2><blockquote><p>There are a lot of classes in <code>angr</code>, and most of them require a project to be instantiated. Instead of making you pass around the project everywhere, we provide <code>project.factory</code>, which has several convenient constructors for common objects you’ll want to use frequently.</p></blockquote><p>angr有很多的类，基本上每一个类都需要一个<code>project</code>对象来实例化。angr提供了<code>project.factory</code>这一个接口，可以方便供我们使用</p><h2 id="Block-block-proj-factory-block-proj-entry"><a href="#Block-block-proj-factory-block-proj-entry" class="headerlink" title="Block  block = proj.factory.block(proj.entry)"></a><em>Block</em> <code> block = proj.factory.block(proj.entry)</code></h2><p>angr的基本执行对象是block，上面这行代码可以获得程序起始地址的块</p><p>What can do with <code>block</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> To see <span class="hljs-built_in">all</span> the instructions: block.pp()<br>out:<span class="hljs-number">0x401670</span>:       xor     ebp, ebp<br><span class="hljs-number">0x401672</span>:       mov     r9, rdx<br><span class="hljs-number">0x401675</span>:       pop     rsi<br><span class="hljs-number">0x401676</span>:       mov     rdx, rsp<br><span class="hljs-number">0x401679</span>:       <span class="hljs-keyword">and</span>     rsp, <span class="hljs-number">0xfffffffffffffff0</span><br><span class="hljs-number">0x40167d</span>:       push    rax<br><span class="hljs-number">0x40167e</span>:       push    rsp<br><span class="hljs-number">0x40167f</span>:       lea     r8, [rip + <span class="hljs-number">0x2e2a</span>]<br><span class="hljs-number">0x401686</span>:       lea     rcx, [rip + <span class="hljs-number">0x2db3</span>]<br><span class="hljs-number">0x40168d</span>:       lea     rdi, [rip - <span class="hljs-number">0xd4</span>]<br><span class="hljs-number">0x401694</span>:       call    qword ptr [rip + <span class="hljs-number">0x205866</span>]<br><span class="hljs-number">2.</span>The number of the instructions:block.instructions<br><span class="hljs-number">3.</span>The address of the instructions: block.instrutions_addr<br>out:[<span class="hljs-number">0x401670</span>, <span class="hljs-number">0x401672</span>, <span class="hljs-number">0x401675</span>, <span class="hljs-number">0x401676</span>, <span class="hljs-number">0x401679</span>, <span class="hljs-number">0x40167d</span>, <span class="hljs-number">0x40167e</span>, <span class="hljs-number">0x40167f</span>, <span class="hljs-number">0x401686</span>, <span class="hljs-number">0x40168d</span>, <span class="hljs-number">0x401694</span>]<br></code></pre></td></tr></table></figure><h2 id="State-state-proj-factory-entry-state"><a href="#State-state-proj-factory-entry-state" class="headerlink" title="State: state = proj.factory.entry_state()"></a><em>State</em>: <code>state = proj.factory.entry_state()</code></h2><p>Some Examples:</p><blockquote><p>Here’s another fact about angr - the <code>Project</code> object only represents an “initialization image” for the program. When you’re performing execution with angr, you are working with a specific object representing a <em>simulated program state</em> - a <code>SimState</code>. Let’s grab one right now!</p></blockquote><p>Project只是程序的一个初始框架，真正符号执行的是一个个<code>SimState</code>,现在创建一个state</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">state = proj.factory.entry_state()<br>&lt;SimState @ <span class="hljs-number">0x401670</span>&gt;<br></code></pre></td></tr></table></figure><blockquote><p>A SimState contains a program’s memory, registers, filesystem data… any “live data” that can be changed by execution has a home in the state.</p></blockquote><p>一个<code>state</code>包含了很多状态，比如内存、寄存器、各种可能改变的值都会存储在state里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-number">1.</span> state.regs.rip <span class="hljs-comment"># get the current instrucion pointer</span><br>out: &lt;BV64 <span class="hljs-number">0x401670</span>&gt;<br><span class="hljs-number">2.</span> state.regs.rax<br>out: &lt;BV64 <span class="hljs-number">0x1c</span>&gt;<br><span class="hljs-number">3.</span> state.mem[proj.entry].<span class="hljs-built_in">int</span>.resolved  <span class="hljs-comment"># interpret the memory at the entry point as a C int</span><br>out: &lt;BV32 <span class="hljs-number">0x8949ed31</span>&gt;<br></code></pre></td></tr></table></figure><p>About <code>bv</code> and <code>bvv</code></p><p><code>bv</code>就是BitVector，angr存储数据的形式；<code>bvv</code>就是BitVector Value，代表这个位向量的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># bv -&gt; bitvectors to represent CPU data in angr</span><br><span class="hljs-comment"># Note that each bitvector has a .length property describing how wide it is in bits.</span><br><br><span class="hljs-number">1.</span> bv = state.solver.BVV(<span class="hljs-number">0x1234</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># create a 32-bit-wide bitvector with value 0x1234</span><br>out: &lt;BV32 <span class="hljs-number">0x1234</span>&gt;<br><span class="hljs-number">2.</span> state.solver.<span class="hljs-built_in">eval</span>(bv)                <span class="hljs-comment"># convert to Python int</span><br>out: <span class="hljs-number">0x1234</span><br></code></pre></td></tr></table></figure><p>存储 <code>bitvectors</code> 到 <code>reg</code> or <code>mem</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>state.regs.rsi = state.solver.BVV(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>)<br>  state.regs.rsi<br>out: &lt;BV64 <span class="hljs-number">0x3</span>&gt;<br><br><span class="hljs-number">2.</span>state.mem[<span class="hljs-number">0x1000</span>].long = <span class="hljs-number">4</span><br>state.mem[<span class="hljs-number">0x1000</span>].long.resolved<br>out:&lt;BV64 <span class="hljs-number">0x4</span>&gt;<br></code></pre></td></tr></table></figure><p>About <code>mem</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>Use array[index] notation to specify an address<br><br><span class="hljs-number">2.</span>Use .&lt;<span class="hljs-built_in">type</span>&gt; to specify that the memory should be interpreted <span class="hljs-keyword">as</span> &amp;lt;<span class="hljs-built_in">type</span>&amp;gt; (common values: char, short, <span class="hljs-built_in">int</span>, long, size_t, uint8_t, uint16_t…)<br><br>From there, you can either:<br><br> <span class="hljs-number">1</span>˚ Store a value to it, either a bitvector <span class="hljs-keyword">or</span> a Python <span class="hljs-built_in">int</span><br><br> <span class="hljs-number">2</span>˚ Use .resolved to get the value <span class="hljs-keyword">as</span> a bitvector<br><br> <span class="hljs-number">3</span>˚ Use .concrete to get the value <span class="hljs-keyword">as</span> a Python <span class="hljs-built_in">int</span><br></code></pre></td></tr></table></figure><h2 id="Simulation-Managers"><a href="#Simulation-Managers" class="headerlink" title="Simulation Managers"></a><em>Simulation Managers</em></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> simgr = proj.factory.simulation_manager(state)<br><span class="hljs-comment">#  The constructor can take a state or a list of states.</span><br>out: &lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br><br><span class="hljs-number">2.</span> simgr.step()<br><span class="hljs-comment"># 这个step会进入block的下个块，如果有分支，那么angr都会进入，后面的文章会再提及</span><br></code></pre></td></tr></table></figure><h2 id="Analyses"><a href="#Analyses" class="headerlink" title="Analyses"></a><em><strong>Analyses</strong></em></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ange has lots of built-in analyses</span><br> proj.analyses.BackwardSlice        proj.analyses.CongruencyCheck      proj.analyses.reload_analyses<br> proj.analyses.BinaryOptimizer      proj.analyses.DDG                  proj.analyses.StaticHooker<br> proj.analyses.BinDiff              proj.analyses.DFG                  proj.analyses.VariableRecovery<br> proj.analyses.BoyScout             proj.analyses.Disassembly          proj.analyses.VariableRecoveryFast<br> proj.analyses.CDG                  proj.analyses.GirlScout            proj.analyses.Veritesting<br> proj.analyses.CFG                  proj.analyses.Identifier           proj.analyses.VFG<br> proj.analyses.CFGEmulated          proj.analyses.LoopFinder           proj.analyses.VSA_DDG<br> proj.analyses.CFGFast              proj.analyses.Reassembler<br></code></pre></td></tr></table></figure><p>for information about these methods, we should check <code>api documention angr.analyses</code></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
      <tag>angr</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
