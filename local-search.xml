<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ExplorationTechnique</title>
    <link href="/2023/05/24/ExplorationTechniques/"/>
    <url>/2023/05/24/ExplorationTechniques/</url>
    
    <content type="html"><![CDATA[<p>About [ExplorationTechnique](<a href="https://docs.angr.io/en/latest/_modules/angr/exploration_techniques.html#ExplorationTechnique">angr.exploration_techniques - angr documentation</a>)</p><span id="more"></span><p>首先，这也是一个类。先来看看angr对这个类的说明</p><blockquote><p><em>An technique is a set of hooks for a simulation manager that assists in the implementation of new techniques in symbolic exploration.</em>      </p><p><em>Any number of these methods may be overridden by a subclass.</em> <em>To use an exploration technique, call <code>simgr.use_technique</code> with an *instance* of the technique.</em></p></blockquote><p>就是说这个technique是一系列hook的集合，可以更好帮助我们符号执行。而且这个类里面的方法都可以使用子类重写，用一个实例来调用<code>simgr.use_technique</code> </p><p>其实这个类就是帮我们把符号执行所必须的几个步骤给我们打包起来，然后让我们重载里面的步骤，新生成一个子类，然后按照这子类里面规定的方法去符号执行</p><p>这是整个类的定义以及相关成员函数的说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExplorationTechnique</span>:<br><br>    <span class="hljs-comment"># 主要hook函数</span><br>    _hook_list = (<span class="hljs-string">&quot;step&quot;</span>, <span class="hljs-string">&quot;filter&quot;</span>, <span class="hljs-string">&quot;selector&quot;</span>, <span class="hljs-string">&quot;step_state&quot;</span>, <span class="hljs-string">&quot;successors&quot;</span>)<br><br>    <span class="hljs-comment"># 得到被重写的hook函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_hooks</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> &#123;name: <span class="hljs-built_in">getattr</span>(self, name) <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> self._hook_list <span class="hljs-keyword">if</span> self._is_overriden(name)&#125;<br>    <br><span class="hljs-comment"># 判断哪些函数被重写</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_is_overriden</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(self, name).__code__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">getattr</span>(ExplorationTechnique, name).__code__<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&quot;project&quot;</span>):<br>            self.project: angr.project.Project = <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 这确实就是一个空函数，专门提供给使用者来初始化自己所要的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self, simgr</span>):<br>        <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">self, simgr, stash=<span class="hljs-string">&quot;active&quot;</span>, **kwargs</span>): <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">         用来hook step函数，最后应该调用simgr.step以便真正执行</span><br><span class="hljs-string">         原本的step是往下执行一步，去到后继block</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        simgr.step(stash=stash, **kwargs)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">self, simgr, state, **kwargs</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">          决定该state要被移去哪一个stash</span><br><span class="hljs-string">          </span><br><span class="hljs-string">          如果说这个state要被filter的话，就把这个state要被移去的stash名字返回</span><br><span class="hljs-string">          如果想在filter之前对state做一些改变，就返回一个stash的元组，并修改state</span><br><span class="hljs-string">          </span><br><span class="hljs-string">          这和step里的filter_fun起到的作用一样的</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> simgr.<span class="hljs-built_in">filter</span>(state, **kwargs)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">selector</span>(<span class="hljs-params">self, simgr, state, **kwargs</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        决定该state是否要参与进这个step round，也就是如果这个state要进入的话，就返</span><br><span class="hljs-string">        回True否则返回False</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        这个step里的selector_fun起到的作用是一样的</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> simgr.selector(state, **kwargs)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">step_state</span>(<span class="hljs-params">self, simgr, state, **kwargs</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        决定该state的successor应该放去哪个块。结果应该是一个stash到successor列表的字典映射</span><br><span class="hljs-string">        如[&quot;active:[succ1,succ2]&quot;]</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        note:该函数的优先级高于filter filter是作用于当前返回的state</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> simgr.step_state(state, **kwargs)<br><br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">successors</span>(<span class="hljs-params">self, simgr, state, **kwargs</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        在进入一个state时调用，返回一个SimSuccssors对象</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> simgr.successors(state, **kwargs)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">complete</span>(<span class="hljs-params">self, simgr</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        返回当前simgr是否到达 &quot;completed&quot; state</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        该方法不是hook的对象，也不应该直接调用此方法，而是应该自己决定返回True或者False</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>setup</code> 初始化</p><p><code>step</code> hook步入</p><p><code>filter</code>决定该state放去哪 即丢去哪</p><p><code>selector</code> 决定该state是否执行 </p><p><code>step_state</code> 决定successors放去哪个stash</p><p><code>successors</code> 在进入一个state时调用</p><p><code>complete</code> 是否全部完成</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Factory SimManger State</title>
    <link href="/2023/05/24/Factory%20SimManger%20State/"/>
    <url>/2023/05/24/Factory%20SimManger%20State/</url>
    
    <content type="html"><![CDATA[<p>简单说说<a href="https://docs.angr.io/en/latest/_modules/angr/factory.html">facntory</a> <a href="https://docs.angr.io/en/latest/_modules/angr/sim_manager.html#SimulationManager">SimManger</a> State关系</p><span id="more"></span><p>一般使用angr时，都会以以下几句开头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br>proj = angr.Project(<span class="hljs-string">&#x27;examples/fauxware/fauxware&#x27;</span>, auto_load_libs=<span class="hljs-literal">False</span>)<br>state = proj.factory.entry_state()<br>simgr = proj.factory.simgr(state)<br></code></pre></td></tr></table></figure><p>现在就来看看<code>factory</code>都究竟是个啥</p><p>首先factory是一个类，但是它更像是一个工具类，帮助我们完成一些事情，我们就可以简单调用里面的方法。比如我们想要初始化一个入口函数的<code>state</code>,那么我们就可以调用<code>factory</code>里面的<code>entry_state()</code>,就不用自己再去关心那细节。</p><p>现在就来看看里面还有哪些方法</p><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="blank-state-self-kwargs"><a href="#blank-state-self-kwargs" class="headerlink" title="blank_state(self, **kwargs)"></a>blank_state(self, **kwargs)</h3><p>调用此方法，会返回一个几乎没有初始化的state对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">blank_state</span>(<span class="hljs-params">self,**kwargs</span>)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Returns a mostly-uninitialized state object. All parameters are optional.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        :param addr:            State 开始的地址</span><br><span class="hljs-string">        :param initial_prefix:  如果提供，所有的符号寄存器都会有一个以此为前缀字符串的符号值</span><br><span class="hljs-string">        :param fs:              A dictionary of file names with associated preset SimFile objects.</span><br><span class="hljs-string">        :param concrete_fs:     bool describing whether the host filesystem should be consulted when opening files.</span><br><span class="hljs-string">        :param chroot:          A path to use as a fake root directory, Behaves similarly to a real chroot. Used only when concrete_fs is set to True.</span><br><span class="hljs-string">        :param kwargs:          Any additional keyword args will be passed to the SimState constructor.</span><br><span class="hljs-string">        :return:                返回一个空 state</span><br><span class="hljs-string">        :rtype:                 返回类型 SimState</span><br><span class="hljs-string"> &quot;&quot;&quot;</span><br> <span class="hljs-keyword">return</span> self.project.simos.state_blank<br></code></pre></td></tr></table></figure><h3 id="entry-state-self-kwargs"><a href="#entry-state-self-kwargs" class="headerlink" title="entry_state(self, **kwargs)"></a>entry_state(self, **kwargs)</h3><p>调用此方法，返回一个起始地址的<code>state</code></p><h3 id="full-init-state-self-kwargs"><a href="#full-init-state-self-kwargs" class="headerlink" title="full_init_state(self, **kwargs)"></a>full_init_state(self, **kwargs)</h3><blockquote><p><em>Very much like :meth:<code>entry_state()</code>, except that instead of starting execution at the program entry point,</em>        <em>execution begins at a special SimProcedure that plays the role of the dynamic loader, calling each of the</em>        <em>initializer functions that should be called before execution reaches the entry point.</em>         <em>It can take any of the arguments that can be provided to <code>entry_state</code>, except for <code>addr</code>.</em></p></blockquote><p>意思是，这个方法拥有以上的所有参数除了addr，因为这个方法是先于符号执行的，它的作用是初始化，调用哪些所有的初始化函数</p><h3 id="call-state-self-addr-args-kwargs"><a href="#call-state-self-addr-args-kwargs" class="headerlink" title="call_state(self, addr, *args, **kwargs)"></a>call_state(self, addr, *args, **kwargs)</h3><p>很显然是一个创建call到某个函数的state，它的参数</p><blockquote><p><em>Returns a state object initialized to the start of a given function, as if it were called with given parameters.</em>         </p><p><em>:param addr:            The address the state should start at instead of the entry point.</em>        </p><p><em>:param args:            Any additional positional arguments will be used as arguments to the function call.</em> </p></blockquote><p>返回一个以给定函数起初地址的<code>state</code>，换句话说提供<code>addr</code>,它将以此创建一个<code>state</code>,而不再是entry point。它也可以通过<code>args</code>来传递所call的函数参数</p><h2 id="Simulation-Manager"><a href="#Simulation-Manager" class="headerlink" title="Simulation Manager"></a>Simulation Manager</h2><h3 id="simgr-simulation-manager-self-thing-Optional-Union-List-SimState-SimState-x3D-None-kwargs"><a href="#simgr-simulation-manager-self-thing-Optional-Union-List-SimState-SimState-x3D-None-kwargs" class="headerlink" title="simgr simulation_manager( self, thing: Optional[Union[List[SimState], SimState]] &#x3D; None,**kwargs)"></a>simgr simulation_manager( self, <strong>thing</strong>: Optional[Union[List[SimState], SimState]] &#x3D; None,**kwargs)</h3><blockquote><p><em>Constructs a new simulation manager.</em>         </p><p><em>:param thing: What to put in the new SimulationManager’s active stash (either a SimState   or a list of</em>  <em>SimStates).</em> </p><p><em>:param kwargs:  Any additional keyword arguments will be passed to the SimulationManager                        constructor</em>        </p><p><em>:returns:               The new SimulationManager</em>        </p><p><em>:rtype:                 angr.sim_manager.SimulationManager</em> </p></blockquote><p>这个方法也很常用，但是它不再是创建和返回state对象，而是利用state对象创建一个simulation manager对象并返回。它的参数就是接受一个state列表或者单独一个state，并把他们放进stash的active里面。如果什么参数也不传，那么它就默认以entry_point为state创建。</p><p>那么这个<code>simulation manager</code>对象是个啥呢？</p><h3 id="SimulationManager"><a href="#SimulationManager" class="headerlink" title="SimulationManager"></a>SimulationManager</h3><p>angr在[文档](<a href="https://docs.angr.io/en/latest/_modules/angr/sim_manager.html#SimulationManager">angr.sim_manager - angr documentation</a>)里面这样评论<em>The Simulation Manager is the future future.</em></p><p>SimulationManager 也是angr里面的一个类。这个类的功能就是帮助我们根据state的stash来管理state，可以往下step，可以过滤filter，也可以融合merge。可以通过属性值来直接获取stash，比如<code>.active</code>,也可以用一些前缀比如<code>mp_</code>,那么就可以<code>mp_active</code>,同理<code>one_</code>.</p><p>这是它的一些成员</p><blockquote><p><em>:param project:           A Project instance.</em>    </p><p><em>:type project:              angr.project.Project</em>   </p><p> <em>:param stashes:</em>           一个字典用于存储stash   </p><p><em>:param active_states:   Active states to seed the “active” stash with.</em>    </p><p><em>:param hierarchy:</em>         一个StateHierarchy对象，用于追踪state之间关系</p><p> <em>:param resilience:</em>        收集error的集合    </p><p><em>:param save_unsat:</em>       如果为True，则保留unsat的state，而不是直接丢掉 </p><p><em>:param auto_drop:</em>        存放直接丢弃的stash的名字</p><p><em>:param completion_mode:</em>     描述exploretion techniques的函数</p><p> <em>:param techniques:</em> 需要预先设定exploretion tech的列表    </p><p>……</p></blockquote><p>当然里面也有很多的方法，最重要的是<code>step</code> ,<code>explore</code>,<code>use_technique</code>三个方法</p><p>看看它的构造函数，通过初始化函数就能这些成员有一个更直观的了解</p><h4 id="init"><a href="#init" class="headerlink" title="__init__"></a>__init__</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        project,</span><br><span class="hljs-params">        active_states=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        stashes=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        hierarchy=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        resilience=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        save_unsat=<span class="hljs-literal">False</span>,</span><br><span class="hljs-params">        auto_drop=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        errored=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        completion_mode=<span class="hljs-built_in">any</span>,</span><br><span class="hljs-params">        techniques=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        suggestions=<span class="hljs-literal">True</span>,</span><br><span class="hljs-params">        **kwargs,</span><br><span class="hljs-params">    </span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br><br>        self._project = project<br>        self.completion_mode = completion_mode<br>        self._errored = []<br>        self._lock = PicklableLock()<br><span class="hljs-comment">#  这里就可以放入自己的stash</span><br>        <span class="hljs-keyword">if</span> stashes <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            stashes = self._create_integral_stashes()<br>        self._stashes: DefaultDict[<span class="hljs-built_in">str</span>, <span class="hljs-type">List</span>[<span class="hljs-string">&quot;SimState&quot;</span>]] = stashes<br>        self._hierarchy = StateHierarchy() <span class="hljs-keyword">if</span> hierarchy <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> hierarchy<br>        self._save_unsat = save_unsat<br>        self._auto_drop = &#123;<br>            SimulationManager.DROP,<br>        &#125;<br>        self._techniques = []<br><br>        <span class="hljs-keyword">if</span> resilience <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._resilience = (AngrError, SimError, claripy.ClaripyError)<br>        <span class="hljs-keyword">elif</span> resilience <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>            self._resilience = (<br>                AngrError,<br>                SimError,<br>                claripy.ClaripyError,<br>                KeyError,<br>                IndexError,<br>                TypeError,<br>                ValueError,<br>                ArithmeticError,<br>                MemoryError,<br>            )<br>        <span class="hljs-keyword">elif</span> resilience <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>            self._resilience = ()<br>        <span class="hljs-keyword">else</span>:<br>            self._resilience = <span class="hljs-built_in">tuple</span>(resilience)<br><br>        <span class="hljs-keyword">if</span> suggestions:<br>            self.use_technique(Suggestions())<br><br>        <span class="hljs-comment"># 8&lt;----------------- Compatibility layer -----------------</span><br><br>        <span class="hljs-keyword">if</span> auto_drop <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> kwargs.pop(<span class="hljs-string">&quot;save_unconstrained&quot;</span>, <span class="hljs-literal">True</span>):<br>            self._auto_drop |= &#123;<span class="hljs-string">&quot;unconstrained&quot;</span>&#125;<br><br>        <span class="hljs-keyword">if</span> kwargs.pop(<span class="hljs-string">&quot;veritesting&quot;</span>, <span class="hljs-literal">False</span>):<br>            self.use_technique(Veritesting(**kwargs.get(<span class="hljs-string">&quot;veritesting_options&quot;</span>, &#123;&#125;)))<br>        kwargs.pop(<span class="hljs-string">&quot;veritesting_options&quot;</span>, &#123;&#125;)<br><br>        threads = kwargs.pop(<span class="hljs-string">&quot;threads&quot;</span>, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> threads <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self.use_technique(Threading(threads))<br><br>        <span class="hljs-keyword">if</span> kwargs:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;Unexpected keyword arguments: &quot;</span> + <span class="hljs-string">&quot; &quot;</span>.join(kwargs))<br>        <span class="hljs-comment"># ------------------ Compatibility layer ----------------&gt;8</span><br><br>        <span class="hljs-keyword">if</span> auto_drop:<br>            self._auto_drop |= <span class="hljs-built_in">set</span>(auto_drop)<br><br>        <span class="hljs-keyword">if</span> errored <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            self._errored.extend(errored)<br><br>        <span class="hljs-keyword">if</span> active_states:<br>            self._store_states(<span class="hljs-string">&quot;active&quot;</span>, active_states)<br><br>        <span class="hljs-keyword">if</span> techniques:<br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> techniques:<br>                self.use_technique(t)<br></code></pre></td></tr></table></figure><h4 id="step"><a href="#step" class="headerlink" title="step"></a>step</h4><p>看看它的参数即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">step</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        stash=<span class="hljs-string">&quot;active&quot;</span>,</span><br><span class="hljs-params">        target_stash=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        n=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        selector_func=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        step_func=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        error_list=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        successor_func=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        until=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        filter_func=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        **run_args,</span><br><span class="hljs-params">    </span>):<br>    <br></code></pre></td></tr></table></figure><blockquote><p><em>stash</em> : 需要step的stash名字，默认是active</p><p><em>target_stash</em> :  将结果放入哪个stash</p><p><em>n</em> :    如果<code>until</code>是NULL的话，那么会一直执行n步</p><p><em><strong>selector_fun</strong></em> : 接收一个以state为参数、返回类型为布尔的函数，如果返回为True，那么执行该                                                                                               state，否则保持原样</p><p><em><strong>step_fun</strong></em> :   接收一个以SimulationManager为参数并返回SimulantionManager的函数，每一次调用<code>step()</code>时，都会调用该函数，但该函数里面不应该有<code>step(</code>)</p><p><em>error_list</em> :一个list来存储<code>ErroredState</code></p><p><em>successor_fun</em> :接收一个以state为参数并返回它后继的函数</p><p>until：  接收一个以SimulationManger为参数并返回布尔值的函数，一直执行到返回为True</p><p><em>filter_func</em> ： 接收一个以state为参数并返回该state要移去哪个stash名字的函数</p></blockquote><p>现在的angr中<code>n</code>和<code>until</code>已经移植到<code>run()</code>中，用法相同</p><h4 id="use-technique"><a href="#use-technique" class="headerlink" title="use_technique"></a>use_technique</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"> Use an exploration technique with this SimulationManager.</span><br><span class="hljs-string"></span><br><span class="hljs-string"> Techniques can be found in :mod:`angr.exploration_techniques`.</span><br><span class="hljs-string"></span><br><span class="hljs-string">:param tech:    一个ExplorationTechnique对象，用以控制该SimluationManger行为</span><br><span class="hljs-string">:type tech:     ExplorationTechnique           （note：ExplorationTechnique也是angr的一个比较重要的类）</span><br><span class="hljs-string">:return:        The technique that was added, for convenience</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(tech, ExplorationTechnique):<br>            <span class="hljs-keyword">raise</span> SimulationManagerError<br><br>        <span class="hljs-comment"># <span class="hljs-doctag">XXX:</span> as promised</span><br>        tech.project = self._project<br>        tech.setup(self)<br><br>        HookSet.install_hooks(self, **tech._get_hooks())<br>        self._techniques.append(tech)<br>        <span class="hljs-keyword">return</span> tech<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>State是一个模拟状态，里面包含很多值，各种寄存器，内存以及几乎所有可以变得值，它是大多数函数的参数。</p><p>我们想要得到一个state，可以调用factory里的关于state的方法。还可以使用得到的state的对象以及factory.simgr方法得到一个SimManger对象。factory相当于一个工具箱，封装angr内部许多常用方法，方便我们调用，就不需要自己手动操作了。</p><p>当我们拥有一个state的时候，就可以把它丢给SimManger了，我们可以到一个SimManger的对象，这一步相当于把这个state拉伸进内存，得到更多有效信息，就可以开始正式执行了，而且我们还可以设定各种执行方式，是只走一步还是一直走到尽头?中间状态要怎么处理？以什么方式走？等等</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simulation Managers</title>
    <link href="/2023/05/24/Simulation-Managers/"/>
    <url>/2023/05/24/Simulation-Managers/</url>
    
    <content type="html"><![CDATA[<p>Stepping Stash-Management Simple-Exploration Exploration-Techniques原文档链接<a href="https://docs.angr.io/en/latest/core-concepts/pathgroups.html#simulation-managers">在此</a></p><span id="more"></span><blockquote><p>The most important control interface in angr is the SimulationManager, which allows you to control symbolic execution over groups of states simultaneously, applying search strategies to explore a program’s state space. Here, you’ll learn how to use it.</p></blockquote><p>概括：angr里面最重要的控制接口就是<code>SimulationManager</code>,可以以此同时控制不同的<code>states</code>符号执行，我们也可以以此来执行我们的搜索策略</p><blockquote><p>Simulation managers let you wrangle multiple states in a slick way. States are organized into “stashes”, which you can step forward, filter, merge, and move around as you wish. This allows you to, for example, step two different stashes of states at different rates, then merge them together. The default stash for most operations is the <code>active</code> stash, which is where your states get put when you initialize a new simulation manager.</p></blockquote><p>概括：我们可以用用<code>Simulation Managers</code>来管理多个<code>states</code>,<code>States</code>又是由<code>stashes</code>组成，这些<code>stashes</code>我们可以步入、过滤、融合甚至移到另一个<code>stashes</code>,对于绝大多数的<code>stashes</code>都是<code>active</code></p><p>note: 这里一直说的<code>stashes</code>其实就是一种状态标志，意味这个block是否还能继续走下去，比如说一个block是<code>active</code>的，那么它就还有后继而且还能继续往下执行。所以当我们初始丢给<code>Simulation Manager</code>的state应该是<code>active</code>的，这样它<code>Simulation Manager</code>才会为我们模拟执行</p><h2 id="Stepping"><a href="#Stepping" class="headerlink" title="Stepping"></a>Stepping</h2><p>一个简单的demo</p><p>我们使用<code>.step()</code>来让当前的state执行一步，去到下一个block。demo中给出了两个block的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> angr<br>proj = angr.Project(<span class="hljs-string">&#x27;examples/fauxware/fauxware&#x27;</span>, auto_load_libs=<span class="hljs-literal">False</span>)<br>state = proj.factory.entry_state()<br>simgr = proj.factory.simgr(state)<br>simgr.active<br>[&lt;SimState @ <span class="hljs-number">0x400580</span>&gt;]<br><br>simgr.step()<br>simgr.active<br>[&lt;SimState @ <span class="hljs-number">0x400540</span>&gt;]<br></code></pre></td></tr></table></figure><p>你一定想问，那如果一个state的后继不止有一个呢？答案是<code>.step()</code>都会执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Step until the first symbolic branch</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(simgr.active) == <span class="hljs-number">1</span>:     <span class="hljs-comment">#只有当前处于active的数量为1，才往下执行</span><br><span class="hljs-meta">... </span>   simgr.step()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">2</span> active&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.active<br>[&lt;SimState @ <span class="hljs-number">0x400692</span>&gt;, &lt;SimState @ <span class="hljs-number">0x400699</span>&gt;]<br><br><span class="hljs-comment"># Step until everything terminates</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr.run()<br><span class="hljs-meta">&gt;&gt;&gt; </span>simgr<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">3</span> deadended&gt;<br></code></pre></td></tr></table></figure><p>如果我们不关心中间过程，只希望它能一直跑下去，直到再也没有后继块可以执行，那么我们可以用.<code>run()</code></p><p>现在我们使用了<code>.run()</code>得到最终的state，它有三个<code>stash</code>,并且都是<code>deadended</code>状态，也就是跑不动了</p><h2 id="Stash-Management"><a href="#Stash-Management" class="headerlink" title="Stash Management"></a>Stash Management</h2><p>我们可以用<code>.move()</code>来转移状态，它有三个参数<code>from_stash</code>,<code>to_statsh</code>,以及一个可选参数<code>filter_func</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">simgr.move(from_stash=<span class="hljs-string">&#x27;deadended&#x27;</span>, to_stash=<span class="hljs-string">&#x27;authenticated&#x27;</span>, filter_func=<span class="hljs-keyword">lambda</span> s: <span class="hljs-string">b&#x27;Welcome&#x27;</span> <span class="hljs-keyword">in</span> s.posix.dumps(<span class="hljs-number">1</span>))<br>simgr<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">2</span> authenticated, <span class="hljs-number">1</span> deadended&gt;<br></code></pre></td></tr></table></figure><p>这个demo让我们把输出含有<code>Welcome</code>的state转移到<code>authenticated</code>，也就是说<code>authenticated</code>里的state都含有<code>Welcome</code></p><p>每一个<code>stash</code>都是一个列表，我们可以用常规的去索引，也可以用其他方法。如果我们加一个前缀<code>one_</code>那么我们就会访问这个<code>stash</code>的第一个元素，如果用<code>mp_</code>就可以同时访问全部，关于<code>mp_</code>这有一个<a href="https://github.com/zardus/mulpyplexer">说明</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> simgr.deadended + simgr.authenticated:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(s.addr))<br><span class="hljs-number">0x1000030</span><br><span class="hljs-number">0x1000078</span><br><span class="hljs-number">0x1000078</span><br><br>simgr.one_deadended<br>&lt;SimState @ <span class="hljs-number">0x1000030</span>&gt;<br>simgr.mp_authenticated<br>MP([&lt;SimState @ <span class="hljs-number">0x1000078</span>&gt;, &lt;SimState @ <span class="hljs-number">0x1000078</span>&gt;])<br>simgr.mp_authenticated.posix.dumps(<span class="hljs-number">0</span>)<br>MP([<span class="hljs-string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00&#x27;</span>,<br>    <span class="hljs-string">&#x27;\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80@\x80@\x00&#x27;</span>])<br></code></pre></td></tr></table></figure><blockquote><p>Of course, <code>step</code>, <code>run</code>, and any other method that operates on a single stash of paths can take a <code>stash</code> argument, specifying which stash to operate on.</p></blockquote><p>也就是所有的<code>step</code>,<code>run</code>方法都可以接受一个<code>stash</code>参数，来决定执行哪一个</p><h3 id="Stash-types"><a href="#Stash-types" class="headerlink" title="Stash types"></a>Stash types</h3><p>You can use stashes for whatever you like, but there are a few stashes that will be used to categorize some special kinds of states. These are:</p><table><thead><tr><th>Stash</th><th>Description</th></tr></thead><tbody><tr><td>active</td><td>可执行的</td></tr><tr><td>deadended</td><td>再也无法执行的，可能是因为无法到达，没有后继等</td></tr><tr><td>pruned</td><td>（不太确定）当使用<code>LAZY_SOLVES</code>时，states不会再检查可满足性，当一个state发现是<code>unsat</code>时，这个states路径上的所有states都会变成<code>pruned</code></td></tr><tr><td>unconstrained</td><td>如果 <code>save_unconstrained</code> 传递给SimelationManager constructor, 那些无约束的就时<code>unconstrained</code></td></tr><tr><td>unsat</td><td>如果 <code>save_unsat</code> 传递给SimelationManager constructor, 那些无解的就时<code>unsat</code>,比如要求输入同时满足即是’AAAA’又是’BBBB’</td></tr></tbody></table><h2 id="Simple-Exploration"><a href="#Simple-Exploration" class="headerlink" title="Simple Exploration"></a>Simple Exploration</h2><p>符号执行很普遍的用法是找到一个可以到达某个地址的states，而忽略其他所有的states，angr提供<code>.explore()</code>来方便执行。</p><p>当我们使用<code>.explore()</code>方法时，它可以接受两个参数<code>find</code>以及<code>avoid</code>。其中<code>find</code>可以是一个地址，一个列表，一个以<code>state</code>为参数返回某些值的函数，当任何一个<code>active</code>符合<code>find</code>的要求，那么它就会被放入<code>found</code>stash里面，同时停止执行，<code>avoid</code>一样，不过是放入<code>avoided</code>stash里面，然后继续符号执行。<code>num_find</code>可以决定找多少个<code>found</code>，简单demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 装载</span><br>proj = angr.Project(<span class="hljs-string">&#x27;examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a&#x27;</span>)<br><span class="hljs-comment"># 创建对象</span><br>simgr = proj.factory.simgr()<br><span class="hljs-comment"># 开始符号执行 搜索</span><br>simgr.explore(find=<span class="hljs-keyword">lambda</span> s: <span class="hljs-string">b&quot;Congrats&quot;</span> <span class="hljs-keyword">in</span> s.posix.dumps(<span class="hljs-number">1</span>))<br>&lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active, <span class="hljs-number">1</span> found&gt;<br><span class="hljs-comment"># 找到一个 利用索引的方式得到该state</span><br>s = simgr.found[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 查看该state的输出</span><br><span class="hljs-built_in">print</span>(s.posix.dumps(<span class="hljs-number">1</span>))<br>Enter password: Congrats!<br><span class="hljs-comment"># 查看该state的输入</span><br>flag = s.posix.dumps(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(flag)<br>g00dJ0B!<br></code></pre></td></tr></table></figure><h2 id="Exploration-Techniques"><a href="#Exploration-Techniques" class="headerlink" title="Exploration Techniques"></a>Exploration Techniques</h2><p>angr内置了很多种的搜索算法，但是我们也可以自己写一个搜索算法，并通过<code>simgr.use_technique(tech)</code>调用，这里的<code>tech</code>是<code>ExplorationTechnique</code>子类。后面会再详谈，这里先列出angr内置的一些搜索算法</p><ul><li><em>DFS</em>: 深度优先，只会让一个state为active，把其他的放进<code>deferred</code>stash</li><li><em>Explorer</em>: 实现<code>.explore()</code>,可以使用<code>find</code>,<code>avoid</code>方法</li><li><em>LengthLimiter</em>:最长路径截断</li><li><em>LoopSeer</em>: 如果可能在一个循环里面，放入<code>spining</code>stash,直到其他可达路径都走完</li><li><em>ManualMergepoint</em>: 标记一个地址作为merge点，当一个stata到达此处时将其挂起，当其他state在某个时间内到达这个点时会被merge</li><li><em>Memory</em>：在<code>.step()</code>之间监视内存释放&#x2F;使用情况,如果内存释放&#x2F;使用得少的话，停止探索</li><li><em>Oppologist</em>: 当angr遇到一个不支持的指令的时候，会具体化所有的输入，并使用unicorn引擎来单独模拟这条指令，使得可以继续符号执行</li><li><em>Spiller</em>: 当有太多states处于active状态时，这可以把一些states放进磁盘中，使得内存开销比较小</li><li><em>Threading</em>: 使用多线程并行处理，但由于python全局变量线程锁的原因，这并不会有多大提升。但是如果在angr的native-code依赖（z3，unicorn，libvex）上花太多时间可以考虑这项技术</li><li><em>Tracer</em>：可以动态追踪资源</li><li><em>Veritesting</em>:自动识别有用的可合并点，使用<code>veritesting=True</code>来启用，这会提高搜索效率，但与其他算法配合得并不是很好</li></ul><p>Look at the API documentation for the <a href="https://docs.angr.io/en/latest/api.html#angr.sim_manager.SimulationManager"><code>SimulationManager</code></a> and <a href="https://docs.angr.io/en/latest/api.html#angr.exploration_techniques.ExplorationTechnique"><code>ExplorationTechnique</code></a> classes for more information.</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Core Concept</title>
    <link href="/2023/05/23/Core-Concept/"/>
    <url>/2023/05/23/Core-Concept/</url>
    
    <content type="html"><![CDATA[<p>最基础的angr，原文档链接<a href="https://docs.angr.io/en/latest/core-concepts/toplevel.html">在此</a></p><span id="more"></span><h2 id="To-start-proj-angr-Project-39-ELF-path-39"><a href="#To-start-proj-angr-Project-39-ELF-path-39" class="headerlink" title="To start: proj = angr.Project(&#39;/ELF_path&#39;)"></a><em>To start</em>: <code>proj = angr.Project(&#39;/ELF_path&#39;)</code></h2><p>We can do these things with <code>proj</code> :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> Check arch: proj.arch <span class="hljs-comment">#查看架构</span><br><span class="hljs-number">2.</span> Check entry: proj.entry <span class="hljs-comment">#查看程序入口</span><br><span class="hljs-number">3.</span> See Name : proj.filename <span class="hljs-comment">#查看文件名字</span><br></code></pre></td></tr></table></figure><h2 id="To-Load-proj-loader"><a href="#To-Load-proj-loader" class="headerlink" title="To Load: proj.loader"></a><em>To Load</em>: <code>proj.loader</code></h2><p>We can do these things with <code>proj.loader</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> See Shared_objects: proj.loader.shared_objects<br><span class="hljs-number">2.</span> See min_addr: proj.loader.min_addr<br><span class="hljs-number">3.</span> see max_addr: proj.loader.max_addr<br><span class="hljs-number">4.</span> See main_object: proj.loader.main_object <span class="hljs-comment"># 主要对象</span><br><span class="hljs-number">5.</span> Check the binary have an executable stack: proj.loader.main_object.execstack<br><span class="hljs-number">6.</span> Check this binary position-independent : proj.loader.main_object.pic<br></code></pre></td></tr></table></figure><h2 id="The-Factory"><a href="#The-Factory" class="headerlink" title="The Factory"></a><em>The Factory</em></h2><blockquote><p>There are a lot of classes in <code>angr</code>, and most of them require a project to be instantiated. Instead of making you pass around the project everywhere, we provide <code>project.factory</code>, which has several convenient constructors for common objects you’ll want to use frequently.</p></blockquote><p>angr有很多的类，基本上每一个类都需要一个<code>project</code>对象来实例化。angr提供了<code>project.factory</code>这一个接口，可以方便供我们使用</p><h2 id="Block-block-proj-factory-block-proj-entry"><a href="#Block-block-proj-factory-block-proj-entry" class="headerlink" title="Block  block = proj.factory.block(proj.entry)"></a><em>Block</em> <code> block = proj.factory.block(proj.entry)</code></h2><p>angr的基本执行对象是block，上面这行代码可以获得程序起始地址的块</p><p>What can do with <code>block</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> To see <span class="hljs-built_in">all</span> the instructions: block.pp()<br>out:<span class="hljs-number">0x401670</span>:       xor     ebp, ebp<br><span class="hljs-number">0x401672</span>:       mov     r9, rdx<br><span class="hljs-number">0x401675</span>:       pop     rsi<br><span class="hljs-number">0x401676</span>:       mov     rdx, rsp<br><span class="hljs-number">0x401679</span>:       <span class="hljs-keyword">and</span>     rsp, <span class="hljs-number">0xfffffffffffffff0</span><br><span class="hljs-number">0x40167d</span>:       push    rax<br><span class="hljs-number">0x40167e</span>:       push    rsp<br><span class="hljs-number">0x40167f</span>:       lea     r8, [rip + <span class="hljs-number">0x2e2a</span>]<br><span class="hljs-number">0x401686</span>:       lea     rcx, [rip + <span class="hljs-number">0x2db3</span>]<br><span class="hljs-number">0x40168d</span>:       lea     rdi, [rip - <span class="hljs-number">0xd4</span>]<br><span class="hljs-number">0x401694</span>:       call    qword ptr [rip + <span class="hljs-number">0x205866</span>]<br><span class="hljs-number">2.</span>The number of the instructions:block.instructions<br><span class="hljs-number">3.</span>The address of the instructions: block.instrutions_addr<br>out:[<span class="hljs-number">0x401670</span>, <span class="hljs-number">0x401672</span>, <span class="hljs-number">0x401675</span>, <span class="hljs-number">0x401676</span>, <span class="hljs-number">0x401679</span>, <span class="hljs-number">0x40167d</span>, <span class="hljs-number">0x40167e</span>, <span class="hljs-number">0x40167f</span>, <span class="hljs-number">0x401686</span>, <span class="hljs-number">0x40168d</span>, <span class="hljs-number">0x401694</span>]<br></code></pre></td></tr></table></figure><h2 id="State-state-proj-factory-entry-state"><a href="#State-state-proj-factory-entry-state" class="headerlink" title="State: state = proj.factory.entry_state()"></a><em>State</em>: <code>state = proj.factory.entry_state()</code></h2><p>Some Examples:</p><blockquote><p>Here’s another fact about angr - the <code>Project</code> object only represents an “initialization image” for the program. When you’re performing execution with angr, you are working with a specific object representing a <em>simulated program state</em> - a <code>SimState</code>. Let’s grab one right now!</p></blockquote><p>Project只是程序的一个初始框架，真正符号执行的是一个个<code>SimState</code>,现在创建一个state</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">state = proj.factory.entry_state()<br>&lt;SimState @ <span class="hljs-number">0x401670</span>&gt;<br></code></pre></td></tr></table></figure><blockquote><p>A SimState contains a program’s memory, registers, filesystem data… any “live data” that can be changed by execution has a home in the state.</p></blockquote><p>一个<code>state</code>包含了很多状态，比如内存、寄存器、各种可能改变的值都会存储在state里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><br><span class="hljs-number">1.</span> state.regs.rip <span class="hljs-comment"># get the current instrucion pointer</span><br>out: &lt;BV64 <span class="hljs-number">0x401670</span>&gt;<br><span class="hljs-number">2.</span> state.regs.rax<br>out: &lt;BV64 <span class="hljs-number">0x1c</span>&gt;<br><span class="hljs-number">3.</span> state.mem[proj.entry].<span class="hljs-built_in">int</span>.resolved  <span class="hljs-comment"># interpret the memory at the entry point as a C int</span><br>out: &lt;BV32 <span class="hljs-number">0x8949ed31</span>&gt;<br></code></pre></td></tr></table></figure><p>About <code>bv</code> and <code>bvv</code></p><p><code>bv</code>就是BitVector，angr存储数据的形式；<code>bvv</code>就是BitVector Value，代表这个位向量的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># bv -&gt; bitvectors to represent CPU data in angr</span><br><span class="hljs-comment"># Note that each bitvector has a .length property describing how wide it is in bits.</span><br><br><span class="hljs-number">1.</span> bv = state.solver.BVV(<span class="hljs-number">0x1234</span>, <span class="hljs-number">32</span>) <span class="hljs-comment"># create a 32-bit-wide bitvector with value 0x1234</span><br>out: &lt;BV32 <span class="hljs-number">0x1234</span>&gt;<br><span class="hljs-number">2.</span> state.solver.<span class="hljs-built_in">eval</span>(bv)                <span class="hljs-comment"># convert to Python int</span><br>out: <span class="hljs-number">0x1234</span><br></code></pre></td></tr></table></figure><p>存储 <code>bitvectors</code> 到 <code>reg</code> or <code>mem</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>state.regs.rsi = state.solver.BVV(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>)<br>  state.regs.rsi<br>out: &lt;BV64 <span class="hljs-number">0x3</span>&gt;<br><br><span class="hljs-number">2.</span>state.mem[<span class="hljs-number">0x1000</span>].long = <span class="hljs-number">4</span><br>state.mem[<span class="hljs-number">0x1000</span>].long.resolved<br>out:&lt;BV64 <span class="hljs-number">0x4</span>&gt;<br></code></pre></td></tr></table></figure><p>About <code>mem</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>Use array[index] notation to specify an address<br><br><span class="hljs-number">2.</span>Use .&lt;<span class="hljs-built_in">type</span>&gt; to specify that the memory should be interpreted <span class="hljs-keyword">as</span> &amp;lt;<span class="hljs-built_in">type</span>&amp;gt; (common values: char, short, <span class="hljs-built_in">int</span>, long, size_t, uint8_t, uint16_t…)<br><br>From there, you can either:<br><br> <span class="hljs-number">1</span>˚ Store a value to it, either a bitvector <span class="hljs-keyword">or</span> a Python <span class="hljs-built_in">int</span><br><br> <span class="hljs-number">2</span>˚ Use .resolved to get the value <span class="hljs-keyword">as</span> a bitvector<br><br> <span class="hljs-number">3</span>˚ Use .concrete to get the value <span class="hljs-keyword">as</span> a Python <span class="hljs-built_in">int</span><br></code></pre></td></tr></table></figure><h2 id="Simulation-Managers"><a href="#Simulation-Managers" class="headerlink" title="Simulation Managers"></a><em>Simulation Managers</em></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> simgr = proj.factory.simulation_manager(state)<br><span class="hljs-comment">#  The constructor can take a state or a list of states.</span><br>out: &lt;SimulationManager <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> active&gt;<br><br><span class="hljs-number">2.</span> simgr.step()<br><span class="hljs-comment"># 这个step会进入block的下个块，如果有分支，那么angr都会进入，后面的文章会再提及</span><br></code></pre></td></tr></table></figure><h2 id="Analyses"><a href="#Analyses" class="headerlink" title="Analyses"></a><em><strong>Analyses</strong></em></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ange has lots of built-in analyses</span><br> proj.analyses.BackwardSlice        proj.analyses.CongruencyCheck      proj.analyses.reload_analyses<br> proj.analyses.BinaryOptimizer      proj.analyses.DDG                  proj.analyses.StaticHooker<br> proj.analyses.BinDiff              proj.analyses.DFG                  proj.analyses.VariableRecovery<br> proj.analyses.BoyScout             proj.analyses.Disassembly          proj.analyses.VariableRecoveryFast<br> proj.analyses.CDG                  proj.analyses.GirlScout            proj.analyses.Veritesting<br> proj.analyses.CFG                  proj.analyses.Identifier           proj.analyses.VFG<br> proj.analyses.CFGEmulated          proj.analyses.LoopFinder           proj.analyses.VSA_DDG<br> proj.analyses.CFGFast              proj.analyses.Reassembler<br></code></pre></td></tr></table></figure><p>for information about these methods, we should check <code>api documention angr.analyses</code></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
